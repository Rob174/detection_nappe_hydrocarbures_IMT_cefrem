<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>main.src.data.Augmentation.Augmenters.Augmenter1 API documentation</title>
<meta name="description" content="Apply all transformations at once thanks to the transformation matrix and warpAffine. Optimized version of Augmenter0" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>main.src.data.Augmentation.Augmenters.Augmenter1</code></h1>
</header>
<section id="section-intro">
<p>Apply all transformations at once thanks to the transformation matrix and warpAffine. Optimized version of Augmenter0</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;Apply all transformations at once thanks to the transformation matrix and warpAffine. Optimized version of Augmenter0&#34;&#34;&#34;

from typing import Tuple, List, Callable

import numpy as np

from main.src.data.Augmentation.Augmentations.AugmentationWithMatrix.RotationResizeMirrors import RotationResizeMirrors
from main.src.param_savers.BaseClass import BaseClass


class Augmenter1(BaseClass):
    &#34;&#34;&#34;Manage and keep track of augmentations to apply on source images only to directly extract patches

    With this class, only one augmentation is supported combinedRotResizeMir which allows to commpute the final patch to be provided to the attr_model after
    rotation, mirrors, resizes (one for augmentation and another to resize the patch to a smaller version)

    This class splits annotation generation and image generation.
    It allows to filter the global sample on the label as it costs less to generate it

        Args:
            allowed_transformations: str, augmentations to apply. Currently supported:
            - combinedRotResizeMir_{rotation_step}_{resize_lower_fact_float}_{resize_upper_fact_float}
            patch_size_before_final_resize: int, size in px of the output patch to extract
            patch_size_final_resize: int, size in px of the output patch provided to the attr_model

    &#34;&#34;&#34;

    def __init__(self, patch_size_before_final_resize: int, patch_size_final_resize: int, allowed_transformations):
        self.attr_allowed_transformations = allowed_transformations
        self.attr_transformations_class = None
        self.attr_patch_size_before_final_resize = patch_size_before_final_resize
        self.attr_patch_size_final_resize = patch_size_final_resize
        self.add_transformation(allowed_transformations, patch_size_before_final_resize, patch_size_final_resize)
        self.attr_augmented_dataset_parameters = {}

    def add_transformation(self, allowed_transformations: str, patch_size_before_final_resize: int,
                           patch_size_final_resize: int):
        &#34;&#34;&#34;Method that map transformation names with actual classes.

        Args:
            allowed_transformations: str, list of augmentations to apply. Currently supported:
            - combinedRotResizeMir_{rotation_step}_{resize_lower_fact_float}_{resize_upper_fact_float}
            patch_size_before_final_resize: int, size in px of the output patch to extract
            patch_size_final_resize: int, size in px of the output patch provided to the attr_model
        Returns:

        &#34;&#34;&#34;
        if &#34;combinedRotResizeMir&#34; in allowed_transformations:
            seen = True
            [_, rotation_step, resize_lower_fact_float, resize_upper_fact_float] = allowed_transformations.split(&#34;_&#34;)
            rotation_step = float(rotation_step)
            resize_lower_fact_float = float(resize_lower_fact_float)
            resize_upper_fact_float = float(resize_upper_fact_float)
            self.attr_transformations_classes = RotationResizeMirrors(rotation_step=rotation_step,
                                                                      resize_lower_fact_float=resize_lower_fact_float,
                                                                      resize_upper_fact_float=resize_upper_fact_float,
                                                                      patch_size_before_final_resize=patch_size_before_final_resize,
                                                                      patch_size_final_resize=patch_size_final_resize
                                                                      )
        else:
            raise NotImplementedError(f&#34;{allowed_transformations} is not implemented&#34;)

    def transform_image(self, image: np.ndarray, partial_transformation_matrix: np.ndarray,
                        patch_upper_left_corner_coords: Tuple[int, int]) -&gt; Tuple[np.ndarray, np.ndarray]:
        &#34;&#34;&#34;Compute the random augmentations in the order in which they have been supplied.

                Apply the same augmentations to the image and to the annotation

                Args:
                    image: np.ndarray, the input image to transform
                    annotation: np.array, the corresponding annotation
                    partial_transformation_matrix: transformation matrix include all augmentations (return values of choose_new_augmentation)
                    patch_upper_left_corner_coords: tuple of int, coordinates of the upperleft corner of the patch in the transformed image

                Returns:
                    tuple of 2 np.ndarray
                    - the transformed image patch*
                    - the transformation matrix

                &#34;&#34;&#34;
        image, partial_transformation_matrix = self.attr_transformations_classes.compute_image_augment(
            image, partial_transformation_matrix,
            coord_patch=patch_upper_left_corner_coords)
        return image, partial_transformation_matrix

    def transform_label(self, annotation_function: Callable, image_name: str, partial_transformation_matrix: np.ndarray,
                        patch_upper_left_corner_coords: Tuple[int, int]) -&gt; Tuple[np.ndarray, np.ndarray]:
        &#34;&#34;&#34;Compute the random mirrors transformations at once on the annotation **points** directly

        It is indeed the only way to avoid new classes introductionn due to interpolation

        Args:
            annotation_function: Callable that can generate the patch with the given parameters
            image_name: str, the name of the original image
            partial_transformation_matrix: transformation matrix include all augmentations (return values of choose_new_augmentation)
            coord_patch: coordinates of the output patch in the augmented image

        Returns:
            tuple of np.ndarray
            - the transformed annotation patch
            - the transformation matrix used
        &#34;&#34;&#34;
        label, partial_transformation_matrix = self.attr_transformations_classes.compute_label_augment(
            annotation_function, image_name, partial_transformation_matrix,
            coord_patch=patch_upper_left_corner_coords)
        return label, partial_transformation_matrix

    def get_grid(self, img_shape, partial_transformation_matrix: np.ndarray) -&gt; List[Tuple[int, int]]:
        &#34;&#34;&#34;Allow to create the adapted grid to the transformation as resize and rotation are involved in the process.


        Args:
            img_shape: shape of the original image
            partial_transformation_matrix: transformation matrix include all augmentations (return values of choose_new_augmentation)

        Returns:
            iterator that produces tuples with coordinates of each upper left corner of each patch
        &#34;&#34;&#34;

        return self.attr_transformations_classes.get_grid(img_shape, partial_transformation_matrix)

    def compute_transformation_matrix(self, rows, cols, angle, resize_factor, mirror):
        &#34;&#34;&#34; Compute the transformation matrix corresponding to the parameters supplied

            Args:
                rows: number of rows of the input image
                cols: number of cols of the input image
                angle, float angle of rotation
                resize_factor, float resize factor taking into account the final resize to get the input image for the model
                mirror, int 0 = fliplr ; 1 = flipud ; -1 = noflip

            Returns:
                np.ndarray, the transformation matrix
            &#34;&#34;&#34;
        return self.attr_transformations_classes.compute_transformation_matrix(rows, cols, angle, resize_factor, mirror)

    def choose_new_augmentations(self, image: np.ndarray) -&gt; np.ndarray:
        &#34;&#34;&#34;Method that allows to create a new augmentation dict containing

        Returns: np.ndarray, transformation matrix to apply the augmentation. It will be further required to &#34;add&#34; (dot multiply) the shift matrix to extract the correct patch
            ⚠️⚠️⚠️⚠️️ coordinates in OPENCV are in the opposite way of the normal row,cols way ⚠️⚠️⚠️⚠
            Internally this matrix include the following transformations:
            - angle
            - resize_factor
            - mirrorlr
            - mirrorud
        &#34;&#34;&#34;
        return self.attr_transformations_classes.choose_new_augmentation(image)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="main.src.data.Augmentation.Augmenters.Augmenter1.Augmenter1"><code class="flex name class">
<span>class <span class="ident">Augmenter1</span></span>
<span>(</span><span>patch_size_before_final_resize: int, patch_size_final_resize: int, allowed_transformations)</span>
</code></dt>
<dd>
<div class="desc"><p>Manage and keep track of augmentations to apply on source images only to directly extract patches</p>
<p>With this class, only one augmentation is supported combinedRotResizeMir which allows to commpute the final patch to be provided to the attr_model after
rotation, mirrors, resizes (one for augmentation and another to resize the patch to a smaller version)</p>
<p>This class splits annotation generation and image generation.
It allows to filter the global sample on the label as it costs less to generate it</p>
<pre><code>Args:
    allowed_transformations: str, augmentations to apply. Currently supported:
    - combinedRotResizeMir_{rotation_step}_{resize_lower_fact_float}_{resize_upper_fact_float}
    patch_size_before_final_resize: int, size in px of the output patch to extract
    patch_size_final_resize: int, size in px of the output patch provided to the attr_model
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Augmenter1(BaseClass):
    &#34;&#34;&#34;Manage and keep track of augmentations to apply on source images only to directly extract patches

    With this class, only one augmentation is supported combinedRotResizeMir which allows to commpute the final patch to be provided to the attr_model after
    rotation, mirrors, resizes (one for augmentation and another to resize the patch to a smaller version)

    This class splits annotation generation and image generation.
    It allows to filter the global sample on the label as it costs less to generate it

        Args:
            allowed_transformations: str, augmentations to apply. Currently supported:
            - combinedRotResizeMir_{rotation_step}_{resize_lower_fact_float}_{resize_upper_fact_float}
            patch_size_before_final_resize: int, size in px of the output patch to extract
            patch_size_final_resize: int, size in px of the output patch provided to the attr_model

    &#34;&#34;&#34;

    def __init__(self, patch_size_before_final_resize: int, patch_size_final_resize: int, allowed_transformations):
        self.attr_allowed_transformations = allowed_transformations
        self.attr_transformations_class = None
        self.attr_patch_size_before_final_resize = patch_size_before_final_resize
        self.attr_patch_size_final_resize = patch_size_final_resize
        self.add_transformation(allowed_transformations, patch_size_before_final_resize, patch_size_final_resize)
        self.attr_augmented_dataset_parameters = {}

    def add_transformation(self, allowed_transformations: str, patch_size_before_final_resize: int,
                           patch_size_final_resize: int):
        &#34;&#34;&#34;Method that map transformation names with actual classes.

        Args:
            allowed_transformations: str, list of augmentations to apply. Currently supported:
            - combinedRotResizeMir_{rotation_step}_{resize_lower_fact_float}_{resize_upper_fact_float}
            patch_size_before_final_resize: int, size in px of the output patch to extract
            patch_size_final_resize: int, size in px of the output patch provided to the attr_model
        Returns:

        &#34;&#34;&#34;
        if &#34;combinedRotResizeMir&#34; in allowed_transformations:
            seen = True
            [_, rotation_step, resize_lower_fact_float, resize_upper_fact_float] = allowed_transformations.split(&#34;_&#34;)
            rotation_step = float(rotation_step)
            resize_lower_fact_float = float(resize_lower_fact_float)
            resize_upper_fact_float = float(resize_upper_fact_float)
            self.attr_transformations_classes = RotationResizeMirrors(rotation_step=rotation_step,
                                                                      resize_lower_fact_float=resize_lower_fact_float,
                                                                      resize_upper_fact_float=resize_upper_fact_float,
                                                                      patch_size_before_final_resize=patch_size_before_final_resize,
                                                                      patch_size_final_resize=patch_size_final_resize
                                                                      )
        else:
            raise NotImplementedError(f&#34;{allowed_transformations} is not implemented&#34;)

    def transform_image(self, image: np.ndarray, partial_transformation_matrix: np.ndarray,
                        patch_upper_left_corner_coords: Tuple[int, int]) -&gt; Tuple[np.ndarray, np.ndarray]:
        &#34;&#34;&#34;Compute the random augmentations in the order in which they have been supplied.

                Apply the same augmentations to the image and to the annotation

                Args:
                    image: np.ndarray, the input image to transform
                    annotation: np.array, the corresponding annotation
                    partial_transformation_matrix: transformation matrix include all augmentations (return values of choose_new_augmentation)
                    patch_upper_left_corner_coords: tuple of int, coordinates of the upperleft corner of the patch in the transformed image

                Returns:
                    tuple of 2 np.ndarray
                    - the transformed image patch*
                    - the transformation matrix

                &#34;&#34;&#34;
        image, partial_transformation_matrix = self.attr_transformations_classes.compute_image_augment(
            image, partial_transformation_matrix,
            coord_patch=patch_upper_left_corner_coords)
        return image, partial_transformation_matrix

    def transform_label(self, annotation_function: Callable, image_name: str, partial_transformation_matrix: np.ndarray,
                        patch_upper_left_corner_coords: Tuple[int, int]) -&gt; Tuple[np.ndarray, np.ndarray]:
        &#34;&#34;&#34;Compute the random mirrors transformations at once on the annotation **points** directly

        It is indeed the only way to avoid new classes introductionn due to interpolation

        Args:
            annotation_function: Callable that can generate the patch with the given parameters
            image_name: str, the name of the original image
            partial_transformation_matrix: transformation matrix include all augmentations (return values of choose_new_augmentation)
            coord_patch: coordinates of the output patch in the augmented image

        Returns:
            tuple of np.ndarray
            - the transformed annotation patch
            - the transformation matrix used
        &#34;&#34;&#34;
        label, partial_transformation_matrix = self.attr_transformations_classes.compute_label_augment(
            annotation_function, image_name, partial_transformation_matrix,
            coord_patch=patch_upper_left_corner_coords)
        return label, partial_transformation_matrix

    def get_grid(self, img_shape, partial_transformation_matrix: np.ndarray) -&gt; List[Tuple[int, int]]:
        &#34;&#34;&#34;Allow to create the adapted grid to the transformation as resize and rotation are involved in the process.


        Args:
            img_shape: shape of the original image
            partial_transformation_matrix: transformation matrix include all augmentations (return values of choose_new_augmentation)

        Returns:
            iterator that produces tuples with coordinates of each upper left corner of each patch
        &#34;&#34;&#34;

        return self.attr_transformations_classes.get_grid(img_shape, partial_transformation_matrix)

    def compute_transformation_matrix(self, rows, cols, angle, resize_factor, mirror):
        &#34;&#34;&#34; Compute the transformation matrix corresponding to the parameters supplied

            Args:
                rows: number of rows of the input image
                cols: number of cols of the input image
                angle, float angle of rotation
                resize_factor, float resize factor taking into account the final resize to get the input image for the model
                mirror, int 0 = fliplr ; 1 = flipud ; -1 = noflip

            Returns:
                np.ndarray, the transformation matrix
            &#34;&#34;&#34;
        return self.attr_transformations_classes.compute_transformation_matrix(rows, cols, angle, resize_factor, mirror)

    def choose_new_augmentations(self, image: np.ndarray) -&gt; np.ndarray:
        &#34;&#34;&#34;Method that allows to create a new augmentation dict containing

        Returns: np.ndarray, transformation matrix to apply the augmentation. It will be further required to &#34;add&#34; (dot multiply) the shift matrix to extract the correct patch
            ⚠️⚠️⚠️⚠️️ coordinates in OPENCV are in the opposite way of the normal row,cols way ⚠️⚠️⚠️⚠
            Internally this matrix include the following transformations:
            - angle
            - resize_factor
            - mirrorlr
            - mirrorud
        &#34;&#34;&#34;
        return self.attr_transformations_classes.choose_new_augmentation(image)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="main.src.param_savers.BaseClass.BaseClass" href="../../../param_savers/BaseClass.html#main.src.param_savers.BaseClass.BaseClass">BaseClass</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="main.src.data.Augmentation.Augmenters.Augmenter1.Augmenter1.add_transformation"><code class="name flex">
<span>def <span class="ident">add_transformation</span></span>(<span>self, allowed_transformations: str, patch_size_before_final_resize: int, patch_size_final_resize: int)</span>
</code></dt>
<dd>
<div class="desc"><p>Method that map transformation names with actual classes.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>allowed_transformations</code></strong></dt>
<dd>str, list of augmentations to apply. Currently supported:</dd>
</dl>
<ul>
<li>
<dl>
<dt>combinedRotResizeMir_{rotation_step}<em resize_upper_fact_float>{resize_lower_fact_float}</em></dt>
<dt><strong><code>patch_size_before_final_resize</code></strong></dt>
<dd>int, size in px of the output patch to extract</dd>
</dl>
</li>
</ul>
<dl>
<dt><strong><code>patch_size_final_resize</code></strong></dt>
<dd>int, size in px of the output patch provided to the attr_model</dd>
</dl>
<p>Returns:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_transformation(self, allowed_transformations: str, patch_size_before_final_resize: int,
                       patch_size_final_resize: int):
    &#34;&#34;&#34;Method that map transformation names with actual classes.

    Args:
        allowed_transformations: str, list of augmentations to apply. Currently supported:
        - combinedRotResizeMir_{rotation_step}_{resize_lower_fact_float}_{resize_upper_fact_float}
        patch_size_before_final_resize: int, size in px of the output patch to extract
        patch_size_final_resize: int, size in px of the output patch provided to the attr_model
    Returns:

    &#34;&#34;&#34;
    if &#34;combinedRotResizeMir&#34; in allowed_transformations:
        seen = True
        [_, rotation_step, resize_lower_fact_float, resize_upper_fact_float] = allowed_transformations.split(&#34;_&#34;)
        rotation_step = float(rotation_step)
        resize_lower_fact_float = float(resize_lower_fact_float)
        resize_upper_fact_float = float(resize_upper_fact_float)
        self.attr_transformations_classes = RotationResizeMirrors(rotation_step=rotation_step,
                                                                  resize_lower_fact_float=resize_lower_fact_float,
                                                                  resize_upper_fact_float=resize_upper_fact_float,
                                                                  patch_size_before_final_resize=patch_size_before_final_resize,
                                                                  patch_size_final_resize=patch_size_final_resize
                                                                  )
    else:
        raise NotImplementedError(f&#34;{allowed_transformations} is not implemented&#34;)</code></pre>
</details>
</dd>
<dt id="main.src.data.Augmentation.Augmenters.Augmenter1.Augmenter1.choose_new_augmentations"><code class="name flex">
<span>def <span class="ident">choose_new_augmentations</span></span>(<span>self, image: numpy.ndarray) ‑> numpy.ndarray</span>
</code></dt>
<dd>
<div class="desc"><p>Method that allows to create a new augmentation dict containing</p>
<p>Returns: np.ndarray, transformation matrix to apply the augmentation. It will be further required to "add" (dot multiply) the shift matrix to extract the correct patch
⚠️⚠️⚠️⚠️️ coordinates in OPENCV are in the opposite way of the normal row,cols way ⚠️⚠️⚠️⚠
Internally this matrix include the following transformations:
- angle
- resize_factor
- mirrorlr
- mirrorud</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def choose_new_augmentations(self, image: np.ndarray) -&gt; np.ndarray:
    &#34;&#34;&#34;Method that allows to create a new augmentation dict containing

    Returns: np.ndarray, transformation matrix to apply the augmentation. It will be further required to &#34;add&#34; (dot multiply) the shift matrix to extract the correct patch
        ⚠️⚠️⚠️⚠️️ coordinates in OPENCV are in the opposite way of the normal row,cols way ⚠️⚠️⚠️⚠
        Internally this matrix include the following transformations:
        - angle
        - resize_factor
        - mirrorlr
        - mirrorud
    &#34;&#34;&#34;
    return self.attr_transformations_classes.choose_new_augmentation(image)</code></pre>
</details>
</dd>
<dt id="main.src.data.Augmentation.Augmenters.Augmenter1.Augmenter1.compute_transformation_matrix"><code class="name flex">
<span>def <span class="ident">compute_transformation_matrix</span></span>(<span>self, rows, cols, angle, resize_factor, mirror)</span>
</code></dt>
<dd>
<div class="desc"><p>Compute the transformation matrix corresponding to the parameters supplied</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>rows</code></strong></dt>
<dd>number of rows of the input image</dd>
<dt><strong><code>cols</code></strong></dt>
<dd>number of cols of the input image</dd>
</dl>
<p>angle, float angle of rotation
resize_factor, float resize factor taking into account the final resize to get the input image for the model
mirror, int 0 = fliplr ; 1 = flipud ; -1 = noflip</p>
<h2 id="returns">Returns</h2>
<p>np.ndarray, the transformation matrix</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def compute_transformation_matrix(self, rows, cols, angle, resize_factor, mirror):
    &#34;&#34;&#34; Compute the transformation matrix corresponding to the parameters supplied

        Args:
            rows: number of rows of the input image
            cols: number of cols of the input image
            angle, float angle of rotation
            resize_factor, float resize factor taking into account the final resize to get the input image for the model
            mirror, int 0 = fliplr ; 1 = flipud ; -1 = noflip

        Returns:
            np.ndarray, the transformation matrix
        &#34;&#34;&#34;
    return self.attr_transformations_classes.compute_transformation_matrix(rows, cols, angle, resize_factor, mirror)</code></pre>
</details>
</dd>
<dt id="main.src.data.Augmentation.Augmenters.Augmenter1.Augmenter1.get_grid"><code class="name flex">
<span>def <span class="ident">get_grid</span></span>(<span>self, img_shape, partial_transformation_matrix: numpy.ndarray) ‑> List[Tuple[int, int]]</span>
</code></dt>
<dd>
<div class="desc"><p>Allow to create the adapted grid to the transformation as resize and rotation are involved in the process.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>img_shape</code></strong></dt>
<dd>shape of the original image</dd>
<dt><strong><code>partial_transformation_matrix</code></strong></dt>
<dd>transformation matrix include all augmentations (return values of choose_new_augmentation)</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>iterator that produces tuples with coordinates of each upper left corner of each patch</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_grid(self, img_shape, partial_transformation_matrix: np.ndarray) -&gt; List[Tuple[int, int]]:
    &#34;&#34;&#34;Allow to create the adapted grid to the transformation as resize and rotation are involved in the process.


    Args:
        img_shape: shape of the original image
        partial_transformation_matrix: transformation matrix include all augmentations (return values of choose_new_augmentation)

    Returns:
        iterator that produces tuples with coordinates of each upper left corner of each patch
    &#34;&#34;&#34;

    return self.attr_transformations_classes.get_grid(img_shape, partial_transformation_matrix)</code></pre>
</details>
</dd>
<dt id="main.src.data.Augmentation.Augmenters.Augmenter1.Augmenter1.transform_image"><code class="name flex">
<span>def <span class="ident">transform_image</span></span>(<span>self, image: numpy.ndarray, partial_transformation_matrix: numpy.ndarray, patch_upper_left_corner_coords: Tuple[int, int]) ‑> Tuple[numpy.ndarray, numpy.ndarray]</span>
</code></dt>
<dd>
<div class="desc"><p>Compute the random augmentations in the order in which they have been supplied.</p>
<p>Apply the same augmentations to the image and to the annotation</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>image</code></strong></dt>
<dd>np.ndarray, the input image to transform</dd>
<dt><strong><code>annotation</code></strong></dt>
<dd>np.array, the corresponding annotation</dd>
<dt><strong><code>partial_transformation_matrix</code></strong></dt>
<dd>transformation matrix include all augmentations (return values of choose_new_augmentation)</dd>
<dt><strong><code>patch_upper_left_corner_coords</code></strong></dt>
<dd>tuple of int, coordinates of the upperleft corner of the patch in the transformed image</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>tuple of 2 np.ndarray
- the transformed image patch*
- the transformation matrix</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def transform_image(self, image: np.ndarray, partial_transformation_matrix: np.ndarray,
                    patch_upper_left_corner_coords: Tuple[int, int]) -&gt; Tuple[np.ndarray, np.ndarray]:
    &#34;&#34;&#34;Compute the random augmentations in the order in which they have been supplied.

            Apply the same augmentations to the image and to the annotation

            Args:
                image: np.ndarray, the input image to transform
                annotation: np.array, the corresponding annotation
                partial_transformation_matrix: transformation matrix include all augmentations (return values of choose_new_augmentation)
                patch_upper_left_corner_coords: tuple of int, coordinates of the upperleft corner of the patch in the transformed image

            Returns:
                tuple of 2 np.ndarray
                - the transformed image patch*
                - the transformation matrix

            &#34;&#34;&#34;
    image, partial_transformation_matrix = self.attr_transformations_classes.compute_image_augment(
        image, partial_transformation_matrix,
        coord_patch=patch_upper_left_corner_coords)
    return image, partial_transformation_matrix</code></pre>
</details>
</dd>
<dt id="main.src.data.Augmentation.Augmenters.Augmenter1.Augmenter1.transform_label"><code class="name flex">
<span>def <span class="ident">transform_label</span></span>(<span>self, annotation_function: Callable, image_name: str, partial_transformation_matrix: numpy.ndarray, patch_upper_left_corner_coords: Tuple[int, int]) ‑> Tuple[numpy.ndarray, numpy.ndarray]</span>
</code></dt>
<dd>
<div class="desc"><p>Compute the random mirrors transformations at once on the annotation <strong>points</strong> directly</p>
<p>It is indeed the only way to avoid new classes introductionn due to interpolation</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>annotation_function</code></strong></dt>
<dd>Callable that can generate the patch with the given parameters</dd>
<dt><strong><code>image_name</code></strong></dt>
<dd>str, the name of the original image</dd>
<dt><strong><code>partial_transformation_matrix</code></strong></dt>
<dd>transformation matrix include all augmentations (return values of choose_new_augmentation)</dd>
<dt><strong><code>coord_patch</code></strong></dt>
<dd>coordinates of the output patch in the augmented image</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>tuple of np.ndarray
- the transformed annotation patch
- the transformation matrix used</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def transform_label(self, annotation_function: Callable, image_name: str, partial_transformation_matrix: np.ndarray,
                    patch_upper_left_corner_coords: Tuple[int, int]) -&gt; Tuple[np.ndarray, np.ndarray]:
    &#34;&#34;&#34;Compute the random mirrors transformations at once on the annotation **points** directly

    It is indeed the only way to avoid new classes introductionn due to interpolation

    Args:
        annotation_function: Callable that can generate the patch with the given parameters
        image_name: str, the name of the original image
        partial_transformation_matrix: transformation matrix include all augmentations (return values of choose_new_augmentation)
        coord_patch: coordinates of the output patch in the augmented image

    Returns:
        tuple of np.ndarray
        - the transformed annotation patch
        - the transformation matrix used
    &#34;&#34;&#34;
    label, partial_transformation_matrix = self.attr_transformations_classes.compute_label_augment(
        annotation_function, image_name, partial_transformation_matrix,
        coord_patch=patch_upper_left_corner_coords)
    return label, partial_transformation_matrix</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="main.src.data.Augmentation.Augmenters" href="index.html">main.src.data.Augmentation.Augmenters</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="main.src.data.Augmentation.Augmenters.Augmenter1.Augmenter1" href="#main.src.data.Augmentation.Augmenters.Augmenter1.Augmenter1">Augmenter1</a></code></h4>
<ul class="">
<li><code><a title="main.src.data.Augmentation.Augmenters.Augmenter1.Augmenter1.add_transformation" href="#main.src.data.Augmentation.Augmenters.Augmenter1.Augmenter1.add_transformation">add_transformation</a></code></li>
<li><code><a title="main.src.data.Augmentation.Augmenters.Augmenter1.Augmenter1.choose_new_augmentations" href="#main.src.data.Augmentation.Augmenters.Augmenter1.Augmenter1.choose_new_augmentations">choose_new_augmentations</a></code></li>
<li><code><a title="main.src.data.Augmentation.Augmenters.Augmenter1.Augmenter1.compute_transformation_matrix" href="#main.src.data.Augmentation.Augmenters.Augmenter1.Augmenter1.compute_transformation_matrix">compute_transformation_matrix</a></code></li>
<li><code><a title="main.src.data.Augmentation.Augmenters.Augmenter1.Augmenter1.get_grid" href="#main.src.data.Augmentation.Augmenters.Augmenter1.Augmenter1.get_grid">get_grid</a></code></li>
<li><code><a title="main.src.data.Augmentation.Augmenters.Augmenter1.Augmenter1.transform_image" href="#main.src.data.Augmentation.Augmenters.Augmenter1.Augmenter1.transform_image">transform_image</a></code></li>
<li><code><a title="main.src.data.Augmentation.Augmenters.Augmenter1.Augmenter1.transform_label" href="#main.src.data.Augmentation.Augmenters.Augmenter1.Augmenter1.transform_label">transform_label</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>