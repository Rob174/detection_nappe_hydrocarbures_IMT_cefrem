<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>main.src.data.Augmentation.Augmentations.AugmentationWithMatrix.RotationResizeMirrors API documentation</title>
<meta name="description" content="Class computing random rotation mirrors resize at once" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>main.src.data.Augmentation.Augmentations.AugmentationWithMatrix.RotationResizeMirrors</code></h1>
</header>
<section id="section-intro">
<p>Class computing random rotation mirrors resize at once</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;Class computing random rotation mirrors resize at once&#34;&#34;&#34;

from typing import Tuple, List, Callable

import cv2
import numpy as np

from main.src.data.Augmentation.Augmentations.AugmentationWithMatrix.AbstractAugmentationWithMatrix import \
    AbstractAugmentationWithMatrix


class RotationResizeMirrors(AbstractAugmentationWithMatrix):
    &#34;&#34;&#34;Class computing random rotation mirrors resize

    Args:
        rotation_step: float, rotation step to take angle between angle 0 and 360Â° with a ... angle step
        resize_lower_fact_float: float, minimal resize factor to resize the original image
        resize_upper_fact_float: float, maximal resize factor to resize the original image
        patch_size_before_final_resize: int, size in px of the output patch to extract
        patch_size_final_resize: int, size in px of the output patch provided to the attr_model

    Usage:

        &gt;&gt;&gt; image = ...
        &gt;&gt;&gt; annotation = ...
        &gt;&gt;&gt; augmentation = RotationResizeMirrors(patch_size_before_final_resize=1000,
        ...                                      patch_size_final_resize=256,rotation_step=15,
        ...                                      resize_lower_fact_float=0.25,
        ...                                      resize_upper_fact_float=4)
        &gt;&gt;&gt; partial_transformation_matrix = augmentation.choose_new_augmentation(image.shape)
        &gt;&gt;&gt; for coord in augmentation.get_grid(image.shape,partial_transformation_matrix):
        ...     patch_array, transformation_matrix = augmentation.compute_image_augment(image,
        ...                                                                              partial_transformation_matrix,
        ...                                                                              coord)
        ...     patch_annotation, _ = augmentation.compute_image_augment(image, partial_transformation_matrix,
        ...                                                              coord)
        ... # Compute the random transformation with the static class
        &gt;&gt;&gt; patch_array.shape
        (256,256)
    &#34;&#34;&#34;

    def __init__(self, patch_size_before_final_resize: int, patch_size_final_resize: int, rotation_step: float,
                 resize_lower_fact_float: float, resize_upper_fact_float: float):
        self.attr_patch_size_before_final_resize = patch_size_before_final_resize
        self.attr_patch_size_final_resize = patch_size_final_resize
        self.attr_rotation_step = rotation_step
        self.attr_resize_upper_fact_float = resize_upper_fact_float
        self.attr_resize_lower_fact_float = resize_lower_fact_float

    def compute_image_augment(self, image: np.ndarray,
                              partial_transformation_matrix: np.ndarray,
                              coord_patch: Tuple[int, int]) -&gt; Tuple[np.ndarray, np.ndarray]:
        &#34;&#34;&#34;Compute the random transformations at once on the image

        Args:
            image: np.ndarray, the original image to transform
            partial_transformation_matrix: transformation matrix include all augmentations (return values of choose_new_augmentation)
            coord_patch: coordinates of the output patch in the augmented image

        Returns:
            tuple of 2 np.ndarray
            - the transformed image patch
            - the transformation matrix used
        &#34;&#34;&#34;

        shift_patch_into_position_matrix = np.array([[1, 0, -coord_patch[1]],
                                                     [0, 1, -coord_patch[0]],
                                                     [0, 0, 1]])
        transformation_matrix = shift_patch_into_position_matrix.dot(partial_transformation_matrix)
        patch_image = cv2.warpAffine(image, transformation_matrix[:-1, :],
                                     dsize=(self.attr_patch_size_final_resize, self.attr_patch_size_final_resize),
                                     flags=cv2.INTER_LANCZOS4)
        return patch_image, transformation_matrix

    def compute_label_augment(self, annotation_function: Callable, image_name: str,
                              partial_transformation_matrix: np.ndarray,
                              coord_patch: Tuple[int, int]) -&gt; Tuple[np.ndarray, np.ndarray]:
        &#34;&#34;&#34;Compute the random mirrors transformations at once on the annotation **points** directly

        It is indeed the only way to avoid new classes introductionn due to interpolation

        Args:
            annotation_function: Callable that can generate the patch with the given parameters
            image_name: str, the name of the original image
            partial_transformation_matrix: transformation matrix include all augmentations (return values of choose_new_augmentation)
            coord_patch: coordinates of the output patch in the augmented image

        Returns:
            tuple of np.ndarray
            - the transformed annotation patch
            - the transformation matrix used
        &#34;&#34;&#34;

        shift_patch_into_position_matrix = np.array([[1, 0, -coord_patch[1]],
                                                     [0, 1, -coord_patch[0]],
                                                     [0, 0, 1]])
        transformation_matrix = shift_patch_into_position_matrix.dot(partial_transformation_matrix)
        annotation = annotation_function(image_name, transformation_matrix, self.attr_patch_size_final_resize)
        return annotation, transformation_matrix

    def get_grid(self, img_shape, partial_transformation_matrix: np.ndarray) -&gt; List[Tuple[int, int]]:
        &#34;&#34;&#34;Allow to create the adapted grid to the transformation as resize and rotation are involved in the process.


        Args:
            img_shape: shape of the original image
            partial_transformation_matrix: transformation matrix include all augmentations (return values of choose_new_augmentation)

        Returns:
            iterator that produces tuples with coordinates of each upper left corner of each patch
        &#34;&#34;&#34;
        rows, cols = img_shape[:2]
        original_mapped_corner1 = partial_transformation_matrix.dot([cols, rows, 1])
        original_mapped_corner2 = partial_transformation_matrix.dot([cols, rows, 1])
        max_rows = max(original_mapped_corner1[1], original_mapped_corner2[1]) - self.attr_patch_size_final_resize
        max_cols = max(original_mapped_corner1[0], original_mapped_corner2[0]) - self.attr_patch_size_final_resize
        cols_coords = np.arange(0, max_cols, self.attr_patch_size_final_resize)
        rows_coords = np.arange(0, max_rows, self.attr_patch_size_final_resize)
        coords = list(zip(*list(x.flat for x in np.meshgrid(rows_coords, cols_coords))))
        return coords

    def choose_parameters(self) -&gt; Tuple[float, float, int]:
        &#34;&#34;&#34;Choose random parameters for augmentations

        Returns: tuple (angle,resize_factor,mirror)
            angle, float angle of rotation
            resize_factor, float resize factor taking into account the final resize to get the input image for the model
            mirror, int 0 = fliplr ; 1 = flipud ; -1 = noflip

        &#34;&#34;&#34;
        angle = np.random.choice(np.arange(0, 361, self.attr_rotation_step))
        resize_factor = np.random.rand() * (
                self.attr_resize_upper_fact_float - self.attr_resize_lower_fact_float) + self.attr_resize_lower_fact_float
        resize_factor *= self.attr_patch_size_final_resize / self.attr_patch_size_before_final_resize

        mirror = np.random.choice([0, 1, -1])
        return angle, resize_factor, mirror

    def compute_transformation_matrix(self, rows: int, cols: int, angle: float, resize_factor: float,
                                      mirror: int) -&gt; np.ndarray:
        &#34;&#34;&#34; Compute the transformation matrix corresponding to the parameters supplied

        Args:
            rows: number of rows of the input image
            cols: number of cols of the input image
            angle, float angle of rotation
            resize_factor, float resize factor taking into account the final resize to get the input image for the model
            mirror, int 0 = fliplr ; 1 = flipud ; -1 = noflip

        Returns:
            np.ndarray, the transformation matrix
        &#34;&#34;&#34;
        # Transformation matrix construction  â ï¸â ï¸â ï¸â ï¸â ï¸â ï¸â ï¸â ï¸ coordinates in OPENCV are in the opposite way of the normal row,cols way
        partial_transformation_matrix = np.identity(3)

        src_points = np.array([[0, 0], [0, rows - 1], [cols - 1, 0], [cols - 1, rows - 1]], dtype=np.float32)
        dst_points = src_points
        if mirror == 0:
            dst_points = np.array([src_points[2], src_points[3], src_points[0], src_points[1]], dtype=np.float32)
        elif mirror == 1:
            dst_points = np.array([src_points[1], src_points[0], src_points[3], src_points[2]], dtype=np.float32)
        mirror_matrix = np.concatenate((cv2.getAffineTransform(src_points[:3], dst_points[:3]), [[0, 0, 1]]), axis=0)
        partial_transformation_matrix = (mirror_matrix.dot(partial_transformation_matrix))
        resize_matrix = np.array([[resize_factor, 0, 0],
                                  [0, resize_factor, 0],
                                  [0, 0, 1]])
        partial_transformation_matrix = resize_matrix.dot(partial_transformation_matrix)
        rotate_matrix = np.concatenate((cv2.getRotationMatrix2D((cols * resize_factor / 2, rows * resize_factor / 2),
                                                                angle=angle, scale=1), [[0, 0, 1]]), axis=0)
        partial_transformation_matrix = rotate_matrix.dot(partial_transformation_matrix)

        adjusted_translation = np.array(
            [[1, 0., -min(0, partial_transformation_matrix.dot([cols - 1, rows - 1, 1])[0])],
             [0, 1, -min(0, partial_transformation_matrix.dot([cols - 1, rows - 1, 1])[1])],
             [0, 0, 1]])
        partial_transformation_matrix = adjusted_translation.dot(partial_transformation_matrix)
        return partial_transformation_matrix

    def choose_new_augmentation(self, image: np.ndarray) -&gt; np.ndarray:
        &#34;&#34;&#34;Method that allows to create a new augmentation dict containing

        Returns: np.ndarray, transformation matrix to apply the augmentation. It will be further required to &#34;add&#34; (dot multiply) the shift matrix to extract the correct patch
            â ï¸â ï¸â ï¸â ï¸ï¸ coordinates in OPENCV are in the opposite way of the normal row,cols way â ï¸â ï¸â ï¸â 
            Internally this matrix include the following transformations:
            - angle
            - resize_factor
            - mirrorlr
            - mirrorud
        &#34;&#34;&#34;
        # Choose parameters of transformation if not already chosen for epoch item
        rows, cols = image.shape[:2]

        return self.compute_transformation_matrix(rows, cols, *self.choose_parameters())</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="main.src.data.Augmentation.Augmentations.AugmentationWithMatrix.RotationResizeMirrors.RotationResizeMirrors"><code class="flex name class">
<span>class <span class="ident">RotationResizeMirrors</span></span>
<span>(</span><span>patch_size_before_final_resize:Â int, patch_size_final_resize:Â int, rotation_step:Â float, resize_lower_fact_float:Â float, resize_upper_fact_float:Â float)</span>
</code></dt>
<dd>
<div class="desc"><p>Class computing random rotation mirrors resize</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>rotation_step</code></strong></dt>
<dd>float, rotation step to take angle between angle 0 and 360Â° with a &hellip; angle step</dd>
<dt><strong><code>resize_lower_fact_float</code></strong></dt>
<dd>float, minimal resize factor to resize the original image</dd>
<dt><strong><code>resize_upper_fact_float</code></strong></dt>
<dd>float, maximal resize factor to resize the original image</dd>
<dt><strong><code>patch_size_before_final_resize</code></strong></dt>
<dd>int, size in px of the output patch to extract</dd>
<dt><strong><code>patch_size_final_resize</code></strong></dt>
<dd>int, size in px of the output patch provided to the attr_model</dd>
</dl>
<h2 id="usage">Usage</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; image = ...
&gt;&gt;&gt; annotation = ...
&gt;&gt;&gt; augmentation = RotationResizeMirrors(patch_size_before_final_resize=1000,
...                                      patch_size_final_resize=256,rotation_step=15,
...                                      resize_lower_fact_float=0.25,
...                                      resize_upper_fact_float=4)
&gt;&gt;&gt; partial_transformation_matrix = augmentation.choose_new_augmentation(image.shape)
&gt;&gt;&gt; for coord in augmentation.get_grid(image.shape,partial_transformation_matrix):
...     patch_array, transformation_matrix = augmentation.compute_image_augment(image,
...                                                                              partial_transformation_matrix,
...                                                                              coord)
...     patch_annotation, _ = augmentation.compute_image_augment(image, partial_transformation_matrix,
...                                                              coord)
... # Compute the random transformation with the static class
&gt;&gt;&gt; patch_array.shape
(256,256)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class RotationResizeMirrors(AbstractAugmentationWithMatrix):
    &#34;&#34;&#34;Class computing random rotation mirrors resize

    Args:
        rotation_step: float, rotation step to take angle between angle 0 and 360Â° with a ... angle step
        resize_lower_fact_float: float, minimal resize factor to resize the original image
        resize_upper_fact_float: float, maximal resize factor to resize the original image
        patch_size_before_final_resize: int, size in px of the output patch to extract
        patch_size_final_resize: int, size in px of the output patch provided to the attr_model

    Usage:

        &gt;&gt;&gt; image = ...
        &gt;&gt;&gt; annotation = ...
        &gt;&gt;&gt; augmentation = RotationResizeMirrors(patch_size_before_final_resize=1000,
        ...                                      patch_size_final_resize=256,rotation_step=15,
        ...                                      resize_lower_fact_float=0.25,
        ...                                      resize_upper_fact_float=4)
        &gt;&gt;&gt; partial_transformation_matrix = augmentation.choose_new_augmentation(image.shape)
        &gt;&gt;&gt; for coord in augmentation.get_grid(image.shape,partial_transformation_matrix):
        ...     patch_array, transformation_matrix = augmentation.compute_image_augment(image,
        ...                                                                              partial_transformation_matrix,
        ...                                                                              coord)
        ...     patch_annotation, _ = augmentation.compute_image_augment(image, partial_transformation_matrix,
        ...                                                              coord)
        ... # Compute the random transformation with the static class
        &gt;&gt;&gt; patch_array.shape
        (256,256)
    &#34;&#34;&#34;

    def __init__(self, patch_size_before_final_resize: int, patch_size_final_resize: int, rotation_step: float,
                 resize_lower_fact_float: float, resize_upper_fact_float: float):
        self.attr_patch_size_before_final_resize = patch_size_before_final_resize
        self.attr_patch_size_final_resize = patch_size_final_resize
        self.attr_rotation_step = rotation_step
        self.attr_resize_upper_fact_float = resize_upper_fact_float
        self.attr_resize_lower_fact_float = resize_lower_fact_float

    def compute_image_augment(self, image: np.ndarray,
                              partial_transformation_matrix: np.ndarray,
                              coord_patch: Tuple[int, int]) -&gt; Tuple[np.ndarray, np.ndarray]:
        &#34;&#34;&#34;Compute the random transformations at once on the image

        Args:
            image: np.ndarray, the original image to transform
            partial_transformation_matrix: transformation matrix include all augmentations (return values of choose_new_augmentation)
            coord_patch: coordinates of the output patch in the augmented image

        Returns:
            tuple of 2 np.ndarray
            - the transformed image patch
            - the transformation matrix used
        &#34;&#34;&#34;

        shift_patch_into_position_matrix = np.array([[1, 0, -coord_patch[1]],
                                                     [0, 1, -coord_patch[0]],
                                                     [0, 0, 1]])
        transformation_matrix = shift_patch_into_position_matrix.dot(partial_transformation_matrix)
        patch_image = cv2.warpAffine(image, transformation_matrix[:-1, :],
                                     dsize=(self.attr_patch_size_final_resize, self.attr_patch_size_final_resize),
                                     flags=cv2.INTER_LANCZOS4)
        return patch_image, transformation_matrix

    def compute_label_augment(self, annotation_function: Callable, image_name: str,
                              partial_transformation_matrix: np.ndarray,
                              coord_patch: Tuple[int, int]) -&gt; Tuple[np.ndarray, np.ndarray]:
        &#34;&#34;&#34;Compute the random mirrors transformations at once on the annotation **points** directly

        It is indeed the only way to avoid new classes introductionn due to interpolation

        Args:
            annotation_function: Callable that can generate the patch with the given parameters
            image_name: str, the name of the original image
            partial_transformation_matrix: transformation matrix include all augmentations (return values of choose_new_augmentation)
            coord_patch: coordinates of the output patch in the augmented image

        Returns:
            tuple of np.ndarray
            - the transformed annotation patch
            - the transformation matrix used
        &#34;&#34;&#34;

        shift_patch_into_position_matrix = np.array([[1, 0, -coord_patch[1]],
                                                     [0, 1, -coord_patch[0]],
                                                     [0, 0, 1]])
        transformation_matrix = shift_patch_into_position_matrix.dot(partial_transformation_matrix)
        annotation = annotation_function(image_name, transformation_matrix, self.attr_patch_size_final_resize)
        return annotation, transformation_matrix

    def get_grid(self, img_shape, partial_transformation_matrix: np.ndarray) -&gt; List[Tuple[int, int]]:
        &#34;&#34;&#34;Allow to create the adapted grid to the transformation as resize and rotation are involved in the process.


        Args:
            img_shape: shape of the original image
            partial_transformation_matrix: transformation matrix include all augmentations (return values of choose_new_augmentation)

        Returns:
            iterator that produces tuples with coordinates of each upper left corner of each patch
        &#34;&#34;&#34;
        rows, cols = img_shape[:2]
        original_mapped_corner1 = partial_transformation_matrix.dot([cols, rows, 1])
        original_mapped_corner2 = partial_transformation_matrix.dot([cols, rows, 1])
        max_rows = max(original_mapped_corner1[1], original_mapped_corner2[1]) - self.attr_patch_size_final_resize
        max_cols = max(original_mapped_corner1[0], original_mapped_corner2[0]) - self.attr_patch_size_final_resize
        cols_coords = np.arange(0, max_cols, self.attr_patch_size_final_resize)
        rows_coords = np.arange(0, max_rows, self.attr_patch_size_final_resize)
        coords = list(zip(*list(x.flat for x in np.meshgrid(rows_coords, cols_coords))))
        return coords

    def choose_parameters(self) -&gt; Tuple[float, float, int]:
        &#34;&#34;&#34;Choose random parameters for augmentations

        Returns: tuple (angle,resize_factor,mirror)
            angle, float angle of rotation
            resize_factor, float resize factor taking into account the final resize to get the input image for the model
            mirror, int 0 = fliplr ; 1 = flipud ; -1 = noflip

        &#34;&#34;&#34;
        angle = np.random.choice(np.arange(0, 361, self.attr_rotation_step))
        resize_factor = np.random.rand() * (
                self.attr_resize_upper_fact_float - self.attr_resize_lower_fact_float) + self.attr_resize_lower_fact_float
        resize_factor *= self.attr_patch_size_final_resize / self.attr_patch_size_before_final_resize

        mirror = np.random.choice([0, 1, -1])
        return angle, resize_factor, mirror

    def compute_transformation_matrix(self, rows: int, cols: int, angle: float, resize_factor: float,
                                      mirror: int) -&gt; np.ndarray:
        &#34;&#34;&#34; Compute the transformation matrix corresponding to the parameters supplied

        Args:
            rows: number of rows of the input image
            cols: number of cols of the input image
            angle, float angle of rotation
            resize_factor, float resize factor taking into account the final resize to get the input image for the model
            mirror, int 0 = fliplr ; 1 = flipud ; -1 = noflip

        Returns:
            np.ndarray, the transformation matrix
        &#34;&#34;&#34;
        # Transformation matrix construction  â ï¸â ï¸â ï¸â ï¸â ï¸â ï¸â ï¸â ï¸ coordinates in OPENCV are in the opposite way of the normal row,cols way
        partial_transformation_matrix = np.identity(3)

        src_points = np.array([[0, 0], [0, rows - 1], [cols - 1, 0], [cols - 1, rows - 1]], dtype=np.float32)
        dst_points = src_points
        if mirror == 0:
            dst_points = np.array([src_points[2], src_points[3], src_points[0], src_points[1]], dtype=np.float32)
        elif mirror == 1:
            dst_points = np.array([src_points[1], src_points[0], src_points[3], src_points[2]], dtype=np.float32)
        mirror_matrix = np.concatenate((cv2.getAffineTransform(src_points[:3], dst_points[:3]), [[0, 0, 1]]), axis=0)
        partial_transformation_matrix = (mirror_matrix.dot(partial_transformation_matrix))
        resize_matrix = np.array([[resize_factor, 0, 0],
                                  [0, resize_factor, 0],
                                  [0, 0, 1]])
        partial_transformation_matrix = resize_matrix.dot(partial_transformation_matrix)
        rotate_matrix = np.concatenate((cv2.getRotationMatrix2D((cols * resize_factor / 2, rows * resize_factor / 2),
                                                                angle=angle, scale=1), [[0, 0, 1]]), axis=0)
        partial_transformation_matrix = rotate_matrix.dot(partial_transformation_matrix)

        adjusted_translation = np.array(
            [[1, 0., -min(0, partial_transformation_matrix.dot([cols - 1, rows - 1, 1])[0])],
             [0, 1, -min(0, partial_transformation_matrix.dot([cols - 1, rows - 1, 1])[1])],
             [0, 0, 1]])
        partial_transformation_matrix = adjusted_translation.dot(partial_transformation_matrix)
        return partial_transformation_matrix

    def choose_new_augmentation(self, image: np.ndarray) -&gt; np.ndarray:
        &#34;&#34;&#34;Method that allows to create a new augmentation dict containing

        Returns: np.ndarray, transformation matrix to apply the augmentation. It will be further required to &#34;add&#34; (dot multiply) the shift matrix to extract the correct patch
            â ï¸â ï¸â ï¸â ï¸ï¸ coordinates in OPENCV are in the opposite way of the normal row,cols way â ï¸â ï¸â ï¸â 
            Internally this matrix include the following transformations:
            - angle
            - resize_factor
            - mirrorlr
            - mirrorud
        &#34;&#34;&#34;
        # Choose parameters of transformation if not already chosen for epoch item
        rows, cols = image.shape[:2]

        return self.compute_transformation_matrix(rows, cols, *self.choose_parameters())</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="main.src.data.Augmentation.Augmentations.AugmentationWithMatrix.AbstractAugmentationWithMatrix.AbstractAugmentationWithMatrix" href="AbstractAugmentationWithMatrix.html#main.src.data.Augmentation.Augmentations.AugmentationWithMatrix.AbstractAugmentationWithMatrix.AbstractAugmentationWithMatrix">AbstractAugmentationWithMatrix</a></li>
<li>abc.ABC</li>
<li><a title="main.src.param_savers.BaseClass.BaseClass" href="../../../../param_savers/BaseClass.html#main.src.param_savers.BaseClass.BaseClass">BaseClass</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="main.src.data.Augmentation.Augmentations.AugmentationWithMatrix.RotationResizeMirrors.RotationResizeMirrors.choose_new_augmentation"><code class="name flex">
<span>def <span class="ident">choose_new_augmentation</span></span>(<span>self, image:Â numpy.ndarray) â>Â numpy.ndarray</span>
</code></dt>
<dd>
<div class="desc"><p>Method that allows to create a new augmentation dict containing</p>
<p>Returns: np.ndarray, transformation matrix to apply the augmentation. It will be further required to "add" (dot multiply) the shift matrix to extract the correct patch
â ï¸â ï¸â ï¸â ï¸ï¸ coordinates in OPENCV are in the opposite way of the normal row,cols way â ï¸â ï¸â ï¸â 
Internally this matrix include the following transformations:
- angle
- resize_factor
- mirrorlr
- mirrorud</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def choose_new_augmentation(self, image: np.ndarray) -&gt; np.ndarray:
    &#34;&#34;&#34;Method that allows to create a new augmentation dict containing

    Returns: np.ndarray, transformation matrix to apply the augmentation. It will be further required to &#34;add&#34; (dot multiply) the shift matrix to extract the correct patch
        â ï¸â ï¸â ï¸â ï¸ï¸ coordinates in OPENCV are in the opposite way of the normal row,cols way â ï¸â ï¸â ï¸â 
        Internally this matrix include the following transformations:
        - angle
        - resize_factor
        - mirrorlr
        - mirrorud
    &#34;&#34;&#34;
    # Choose parameters of transformation if not already chosen for epoch item
    rows, cols = image.shape[:2]

    return self.compute_transformation_matrix(rows, cols, *self.choose_parameters())</code></pre>
</details>
</dd>
<dt id="main.src.data.Augmentation.Augmentations.AugmentationWithMatrix.RotationResizeMirrors.RotationResizeMirrors.choose_parameters"><code class="name flex">
<span>def <span class="ident">choose_parameters</span></span>(<span>self) â>Â Tuple[float,Â float,Â int]</span>
</code></dt>
<dd>
<div class="desc"><p>Choose random parameters for augmentations</p>
<p>Returns: tuple (angle,resize_factor,mirror)
angle, float angle of rotation
resize_factor, float resize factor taking into account the final resize to get the input image for the model
mirror, int 0 = fliplr ; 1 = flipud ; -1 = noflip</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def choose_parameters(self) -&gt; Tuple[float, float, int]:
    &#34;&#34;&#34;Choose random parameters for augmentations

    Returns: tuple (angle,resize_factor,mirror)
        angle, float angle of rotation
        resize_factor, float resize factor taking into account the final resize to get the input image for the model
        mirror, int 0 = fliplr ; 1 = flipud ; -1 = noflip

    &#34;&#34;&#34;
    angle = np.random.choice(np.arange(0, 361, self.attr_rotation_step))
    resize_factor = np.random.rand() * (
            self.attr_resize_upper_fact_float - self.attr_resize_lower_fact_float) + self.attr_resize_lower_fact_float
    resize_factor *= self.attr_patch_size_final_resize / self.attr_patch_size_before_final_resize

    mirror = np.random.choice([0, 1, -1])
    return angle, resize_factor, mirror</code></pre>
</details>
</dd>
<dt id="main.src.data.Augmentation.Augmentations.AugmentationWithMatrix.RotationResizeMirrors.RotationResizeMirrors.compute_image_augment"><code class="name flex">
<span>def <span class="ident">compute_image_augment</span></span>(<span>self, image:Â numpy.ndarray, partial_transformation_matrix:Â numpy.ndarray, coord_patch:Â Tuple[int,Â int]) â>Â Tuple[numpy.ndarray,Â numpy.ndarray]</span>
</code></dt>
<dd>
<div class="desc"><p>Compute the random transformations at once on the image</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>image</code></strong></dt>
<dd>np.ndarray, the original image to transform</dd>
<dt><strong><code>partial_transformation_matrix</code></strong></dt>
<dd>transformation matrix include all augmentations (return values of choose_new_augmentation)</dd>
<dt><strong><code>coord_patch</code></strong></dt>
<dd>coordinates of the output patch in the augmented image</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>tuple of 2 np.ndarray
- the transformed image patch
- the transformation matrix used</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def compute_image_augment(self, image: np.ndarray,
                          partial_transformation_matrix: np.ndarray,
                          coord_patch: Tuple[int, int]) -&gt; Tuple[np.ndarray, np.ndarray]:
    &#34;&#34;&#34;Compute the random transformations at once on the image

    Args:
        image: np.ndarray, the original image to transform
        partial_transformation_matrix: transformation matrix include all augmentations (return values of choose_new_augmentation)
        coord_patch: coordinates of the output patch in the augmented image

    Returns:
        tuple of 2 np.ndarray
        - the transformed image patch
        - the transformation matrix used
    &#34;&#34;&#34;

    shift_patch_into_position_matrix = np.array([[1, 0, -coord_patch[1]],
                                                 [0, 1, -coord_patch[0]],
                                                 [0, 0, 1]])
    transformation_matrix = shift_patch_into_position_matrix.dot(partial_transformation_matrix)
    patch_image = cv2.warpAffine(image, transformation_matrix[:-1, :],
                                 dsize=(self.attr_patch_size_final_resize, self.attr_patch_size_final_resize),
                                 flags=cv2.INTER_LANCZOS4)
    return patch_image, transformation_matrix</code></pre>
</details>
</dd>
<dt id="main.src.data.Augmentation.Augmentations.AugmentationWithMatrix.RotationResizeMirrors.RotationResizeMirrors.compute_label_augment"><code class="name flex">
<span>def <span class="ident">compute_label_augment</span></span>(<span>self, annotation_function:Â Callable, image_name:Â str, partial_transformation_matrix:Â numpy.ndarray, coord_patch:Â Tuple[int,Â int]) â>Â Tuple[numpy.ndarray,Â numpy.ndarray]</span>
</code></dt>
<dd>
<div class="desc"><p>Compute the random mirrors transformations at once on the annotation <strong>points</strong> directly</p>
<p>It is indeed the only way to avoid new classes introductionn due to interpolation</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>annotation_function</code></strong></dt>
<dd>Callable that can generate the patch with the given parameters</dd>
<dt><strong><code>image_name</code></strong></dt>
<dd>str, the name of the original image</dd>
<dt><strong><code>partial_transformation_matrix</code></strong></dt>
<dd>transformation matrix include all augmentations (return values of choose_new_augmentation)</dd>
<dt><strong><code>coord_patch</code></strong></dt>
<dd>coordinates of the output patch in the augmented image</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>tuple of np.ndarray
- the transformed annotation patch
- the transformation matrix used</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def compute_label_augment(self, annotation_function: Callable, image_name: str,
                          partial_transformation_matrix: np.ndarray,
                          coord_patch: Tuple[int, int]) -&gt; Tuple[np.ndarray, np.ndarray]:
    &#34;&#34;&#34;Compute the random mirrors transformations at once on the annotation **points** directly

    It is indeed the only way to avoid new classes introductionn due to interpolation

    Args:
        annotation_function: Callable that can generate the patch with the given parameters
        image_name: str, the name of the original image
        partial_transformation_matrix: transformation matrix include all augmentations (return values of choose_new_augmentation)
        coord_patch: coordinates of the output patch in the augmented image

    Returns:
        tuple of np.ndarray
        - the transformed annotation patch
        - the transformation matrix used
    &#34;&#34;&#34;

    shift_patch_into_position_matrix = np.array([[1, 0, -coord_patch[1]],
                                                 [0, 1, -coord_patch[0]],
                                                 [0, 0, 1]])
    transformation_matrix = shift_patch_into_position_matrix.dot(partial_transformation_matrix)
    annotation = annotation_function(image_name, transformation_matrix, self.attr_patch_size_final_resize)
    return annotation, transformation_matrix</code></pre>
</details>
</dd>
<dt id="main.src.data.Augmentation.Augmentations.AugmentationWithMatrix.RotationResizeMirrors.RotationResizeMirrors.compute_transformation_matrix"><code class="name flex">
<span>def <span class="ident">compute_transformation_matrix</span></span>(<span>self, rows:Â int, cols:Â int, angle:Â float, resize_factor:Â float, mirror:Â int) â>Â numpy.ndarray</span>
</code></dt>
<dd>
<div class="desc"><p>Compute the transformation matrix corresponding to the parameters supplied</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>rows</code></strong></dt>
<dd>number of rows of the input image</dd>
<dt><strong><code>cols</code></strong></dt>
<dd>number of cols of the input image</dd>
</dl>
<p>angle, float angle of rotation
resize_factor, float resize factor taking into account the final resize to get the input image for the model
mirror, int 0 = fliplr ; 1 = flipud ; -1 = noflip</p>
<h2 id="returns">Returns</h2>
<p>np.ndarray, the transformation matrix</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def compute_transformation_matrix(self, rows: int, cols: int, angle: float, resize_factor: float,
                                  mirror: int) -&gt; np.ndarray:
    &#34;&#34;&#34; Compute the transformation matrix corresponding to the parameters supplied

    Args:
        rows: number of rows of the input image
        cols: number of cols of the input image
        angle, float angle of rotation
        resize_factor, float resize factor taking into account the final resize to get the input image for the model
        mirror, int 0 = fliplr ; 1 = flipud ; -1 = noflip

    Returns:
        np.ndarray, the transformation matrix
    &#34;&#34;&#34;
    # Transformation matrix construction  â ï¸â ï¸â ï¸â ï¸â ï¸â ï¸â ï¸â ï¸ coordinates in OPENCV are in the opposite way of the normal row,cols way
    partial_transformation_matrix = np.identity(3)

    src_points = np.array([[0, 0], [0, rows - 1], [cols - 1, 0], [cols - 1, rows - 1]], dtype=np.float32)
    dst_points = src_points
    if mirror == 0:
        dst_points = np.array([src_points[2], src_points[3], src_points[0], src_points[1]], dtype=np.float32)
    elif mirror == 1:
        dst_points = np.array([src_points[1], src_points[0], src_points[3], src_points[2]], dtype=np.float32)
    mirror_matrix = np.concatenate((cv2.getAffineTransform(src_points[:3], dst_points[:3]), [[0, 0, 1]]), axis=0)
    partial_transformation_matrix = (mirror_matrix.dot(partial_transformation_matrix))
    resize_matrix = np.array([[resize_factor, 0, 0],
                              [0, resize_factor, 0],
                              [0, 0, 1]])
    partial_transformation_matrix = resize_matrix.dot(partial_transformation_matrix)
    rotate_matrix = np.concatenate((cv2.getRotationMatrix2D((cols * resize_factor / 2, rows * resize_factor / 2),
                                                            angle=angle, scale=1), [[0, 0, 1]]), axis=0)
    partial_transformation_matrix = rotate_matrix.dot(partial_transformation_matrix)

    adjusted_translation = np.array(
        [[1, 0., -min(0, partial_transformation_matrix.dot([cols - 1, rows - 1, 1])[0])],
         [0, 1, -min(0, partial_transformation_matrix.dot([cols - 1, rows - 1, 1])[1])],
         [0, 0, 1]])
    partial_transformation_matrix = adjusted_translation.dot(partial_transformation_matrix)
    return partial_transformation_matrix</code></pre>
</details>
</dd>
<dt id="main.src.data.Augmentation.Augmentations.AugmentationWithMatrix.RotationResizeMirrors.RotationResizeMirrors.get_grid"><code class="name flex">
<span>def <span class="ident">get_grid</span></span>(<span>self, img_shape, partial_transformation_matrix:Â numpy.ndarray) â>Â List[Tuple[int,Â int]]</span>
</code></dt>
<dd>
<div class="desc"><p>Allow to create the adapted grid to the transformation as resize and rotation are involved in the process.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>img_shape</code></strong></dt>
<dd>shape of the original image</dd>
<dt><strong><code>partial_transformation_matrix</code></strong></dt>
<dd>transformation matrix include all augmentations (return values of choose_new_augmentation)</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>iterator that produces tuples with coordinates of each upper left corner of each patch</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_grid(self, img_shape, partial_transformation_matrix: np.ndarray) -&gt; List[Tuple[int, int]]:
    &#34;&#34;&#34;Allow to create the adapted grid to the transformation as resize and rotation are involved in the process.


    Args:
        img_shape: shape of the original image
        partial_transformation_matrix: transformation matrix include all augmentations (return values of choose_new_augmentation)

    Returns:
        iterator that produces tuples with coordinates of each upper left corner of each patch
    &#34;&#34;&#34;
    rows, cols = img_shape[:2]
    original_mapped_corner1 = partial_transformation_matrix.dot([cols, rows, 1])
    original_mapped_corner2 = partial_transformation_matrix.dot([cols, rows, 1])
    max_rows = max(original_mapped_corner1[1], original_mapped_corner2[1]) - self.attr_patch_size_final_resize
    max_cols = max(original_mapped_corner1[0], original_mapped_corner2[0]) - self.attr_patch_size_final_resize
    cols_coords = np.arange(0, max_cols, self.attr_patch_size_final_resize)
    rows_coords = np.arange(0, max_rows, self.attr_patch_size_final_resize)
    coords = list(zip(*list(x.flat for x in np.meshgrid(rows_coords, cols_coords))))
    return coords</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="main.src.data.Augmentation.Augmentations.AugmentationWithMatrix" href="index.html">main.src.data.Augmentation.Augmentations.AugmentationWithMatrix</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="main.src.data.Augmentation.Augmentations.AugmentationWithMatrix.RotationResizeMirrors.RotationResizeMirrors" href="#main.src.data.Augmentation.Augmentations.AugmentationWithMatrix.RotationResizeMirrors.RotationResizeMirrors">RotationResizeMirrors</a></code></h4>
<ul class="">
<li><code><a title="main.src.data.Augmentation.Augmentations.AugmentationWithMatrix.RotationResizeMirrors.RotationResizeMirrors.choose_new_augmentation" href="#main.src.data.Augmentation.Augmentations.AugmentationWithMatrix.RotationResizeMirrors.RotationResizeMirrors.choose_new_augmentation">choose_new_augmentation</a></code></li>
<li><code><a title="main.src.data.Augmentation.Augmentations.AugmentationWithMatrix.RotationResizeMirrors.RotationResizeMirrors.choose_parameters" href="#main.src.data.Augmentation.Augmentations.AugmentationWithMatrix.RotationResizeMirrors.RotationResizeMirrors.choose_parameters">choose_parameters</a></code></li>
<li><code><a title="main.src.data.Augmentation.Augmentations.AugmentationWithMatrix.RotationResizeMirrors.RotationResizeMirrors.compute_image_augment" href="#main.src.data.Augmentation.Augmentations.AugmentationWithMatrix.RotationResizeMirrors.RotationResizeMirrors.compute_image_augment">compute_image_augment</a></code></li>
<li><code><a title="main.src.data.Augmentation.Augmentations.AugmentationWithMatrix.RotationResizeMirrors.RotationResizeMirrors.compute_label_augment" href="#main.src.data.Augmentation.Augmentations.AugmentationWithMatrix.RotationResizeMirrors.RotationResizeMirrors.compute_label_augment">compute_label_augment</a></code></li>
<li><code><a title="main.src.data.Augmentation.Augmentations.AugmentationWithMatrix.RotationResizeMirrors.RotationResizeMirrors.compute_transformation_matrix" href="#main.src.data.Augmentation.Augmentations.AugmentationWithMatrix.RotationResizeMirrors.RotationResizeMirrors.compute_transformation_matrix">compute_transformation_matrix</a></code></li>
<li><code><a title="main.src.data.Augmentation.Augmentations.AugmentationWithMatrix.RotationResizeMirrors.RotationResizeMirrors.get_grid" href="#main.src.data.Augmentation.Augmentations.AugmentationWithMatrix.RotationResizeMirrors.RotationResizeMirrors.get_grid">get_grid</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>