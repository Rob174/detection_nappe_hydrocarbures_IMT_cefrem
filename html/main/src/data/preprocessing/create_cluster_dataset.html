<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>main.src.data.preprocessing.create_cluster_dataset API documentation</title>
<meta name="description" content="Script that allows to create gather images into clusters of images according to a minimal distance below a px threshold distance (cf variable …" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>main.src.data.preprocessing.create_cluster_dataset</code></h1>
</header>
<section id="section-intro">
<p>Script that allows to create gather images into clusters of images according to a minimal distance below a px threshold distance (cf variable threshold)
This functionnality has been postponed due to better solution (storing directly static patches into an hdf5 cache</p>
<p>if you want to continue to develop this functionnality, there is the following todo list:
- create bounding box with opencv OR minAreaRect with rotation (to store less data)
- check width height boxes statistics and ensure that patches of 1000, (~1500 ?) px can be computed without margins</p>
<ul>
<li>launch final algo on all images into a new hdf5 file (⚠️⚠️ check if there is enough hard drive memory before)</li>
</ul>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;Script that allows to create gather images into clusters of images according to a minimal distance below a px threshold distance (cf variable threshold)
This functionnality has been postponed due to better solution (storing directly static patches into an hdf5 cache

if you want to continue to develop this functionnality, there is the following todo list:
- create bounding box with opencv OR minAreaRect with rotation (to store less data)
- check width height boxes statistics and ensure that patches of 1000, (~1500 ?) px can be computed without margins

- launch final algo on all images into a new hdf5 file (⚠️⚠️ check if there is enough hard drive memory before)
&#34;&#34;&#34;
import colorsys

import cv2
import matplotlib
import matplotlib.pyplot as plt
import numpy as np
from PIL import Image, ImageDraw
from h5py import File
from scipy.optimize import minimize, LinearConstraint

from main.src.data.preprocessing.correct_overlap_annotations import get_annotations, get_annotations_points

distance = lambda point1, point2: np.sqrt((point1[0] - point2[0]) ** 2 + (point1[1] - point2[1]) ** 2)


def min_distance(x1, y1, x2, y2, x3, y3, x4, y4):
    A = np.array([[2 * ((x1 - x2) ** 2 + (y1 - y2) ** 2), 2 * ((x1 - x2) * (x3 - x4) + (y1 - y2) * (y3 - y4))],
                  [2 * ((x1 - x2) * (x3 - x4) + (y1 - y2) * (y3 - y4)), 2 * ((x3 - x4) ** 2 + (y3 - y4) ** 2)]])

    B = np.array([[-2 * ((x1 - x2) * (x2 - x4) + (y1 - y2) * (y2 + y4))],
                  [-2 * ((x3 - x4) * (x2 - x4) + (y3 - y4) * (y2 + y4))]])

    # We want find the smallest distance between two point of two edges defined by their extremal points
    # One point satisfies the property that x = λx1 + (1-λ)x2 ; (idem with y) with x1,x2 (resp y1,y2) the x-(resp y) coordinates
    # of the extrimity of this vertex, with λ ∈ [0,1]
    # So we want to minimize
    #    ___________________________________________________________________________________________________________________
    #   ╱                                                     2                                                        2
    # ╲╱ ((λ1 ⋅ x1 + (1 - λ1) ⋅ x2) - (λ2 ⋅ x3 + (1 - λ2) ⋅ x4))  + ((λ1 ⋅ y1 + (1 - λ1) ⋅ y2) - (λ2 ⋅ y3 + (1 - λ2) ⋅ y4))
    # it is a non linear minimization problem with constraints. We will use trust-constr algorithm from scipy
    distance_btw_two_points_on_edges = lambda lambdas: distance(
        [lambdas[0] * x1 + (1 - lambdas[0]) * x2, lambdas[0] * y1 + (1 - lambdas[0]) * y2],
        [lambdas[1] * x3 + (1 - lambdas[1]) * x4, lambdas[1] * y3 + (1 - lambdas[1]) * y4])
    grad = np.array
    res = minimize(distance_btw_two_points_on_edges, [0.1, 0.1], method=&#39;trust-constr&#39;, options={&#39;disp&#39;: False},
                   tol=0.4,  # tolerance of 0.4 as we have a px distance
                   constraints=LinearConstraint(A=np.identity(2), lb=np.zeros((2,)) + 1e-3,
                                                ub=np.ones((2,))))  # λ ∈ [0,1]
    if res.success is False:
        raise Exception(&#34;Pb with minimization method: try to change the method used in the minimize function&#34;)
    return distance_btw_two_points_on_edges(res.x)


def do():
    annotations, name_to_annotations = get_annotations_points(*get_annotations())
    list_cluster_dims = []
    with File(
            r&#34;C:\Users\robin\Documents\projets\detection_nappe_hydrocarbures_IMT_cefrem\data_in\annotations_labels_preprocessed.hdf5&#34;,
            &#34;r&#34;) as cache:
        for i, [name, img] in enumerate(cache.items()):
            print(&#34;----------------------------------------------&#34;)
            img = np.copy(np.array(img, dtype=np.uint8))
            classe = 1
            lshapes = [annotations[i][&#34;points&#34;] for i in name_to_annotations[name]]
            if len(lshapes) == 0:
                return None
            lclusters = []
            dist_clustering_max = 250
            for points in lshapes:  # For each shape
                if len(lclusters) == 0:
                    lclusters.append([points])
                else:
                    added_to_existing_cluster = False
                    for i, cluster_list in enumerate(
                            lclusters):  # We iterate over cluster and search if this shape is nearby a cluster
                        for shape_cluster_points in cluster_list:
                            # We check if one min distance between two vertrices is lower than the threshold
                            for vertex_pt1, vertex_pt2 in zip(shape_cluster_points,
                                                              shape_cluster_points[1:] + [shape_cluster_points[0]]):
                                for point1, point2 in zip(points, points[1:] + [points[0]]):
                                    try:
                                        if min_distance(*vertex_pt1, *vertex_pt2,
                                                        *point1, *point2) &lt; dist_clustering_max:
                                            lclusters[i].append(points)
                                            added_to_existing_cluster = True
                                            break
                                    except Exception as e:
                                        print(e)
                                        raise Exception()

                                if added_to_existing_cluster is True:
                                    break
                            if added_to_existing_cluster is True:
                                break
                        if added_to_existing_cluster is True:
                            break
                    if added_to_existing_cluster is False:
                        lclusters.append([points])
            # Drawing the shapes with one color per cluster: only for debugging purpose
            # Use directly all points from each cluster to compute boxes
            clean_img = np.zeros((*img.shape, 3), dtype=np.uint8)
            segmentation_map = Image.fromarray(clean_img)
            draw = ImageDraw.ImageDraw(segmentation_map)
            get_color = lambda x: matplotlib.colors.to_hex([*colorsys.hsv_to_rgb(x / len(lclusters), 1, 1)])
            print(f&#34;{len(lclusters)} clusters found&#34;)
            for i, cluster in enumerate(lclusters):
                print(f&#34;\t- {len(cluster)} shapes : &#34;, cluster)
                cv2.minAreaRect(np.array())
                for shape_points in cluster:
                    color = get_color(i)
                    draw.polygon(shape_points, fill=color)

            plt.figure()
            plt.imshow(np.asarray(segmentation_map), cmap=&#34;gray&#34;)
            plt.figure()
            plt.imshow(img.astype(np.uint8), cmap=&#34;gray&#34;)
            plt.show()
            break


if __name__ == &#34;__main__&#34;:
    do()</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="main.src.data.preprocessing.create_cluster_dataset.distance"><code class="name flex">
<span>def <span class="ident">distance</span></span>(<span>point1, point2)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">distance = lambda point1, point2: np.sqrt((point1[0] - point2[0]) ** 2 + (point1[1] - point2[1]) ** 2)</code></pre>
</details>
</dd>
<dt id="main.src.data.preprocessing.create_cluster_dataset.do"><code class="name flex">
<span>def <span class="ident">do</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def do():
    annotations, name_to_annotations = get_annotations_points(*get_annotations())
    list_cluster_dims = []
    with File(
            r&#34;C:\Users\robin\Documents\projets\detection_nappe_hydrocarbures_IMT_cefrem\data_in\annotations_labels_preprocessed.hdf5&#34;,
            &#34;r&#34;) as cache:
        for i, [name, img] in enumerate(cache.items()):
            print(&#34;----------------------------------------------&#34;)
            img = np.copy(np.array(img, dtype=np.uint8))
            classe = 1
            lshapes = [annotations[i][&#34;points&#34;] for i in name_to_annotations[name]]
            if len(lshapes) == 0:
                return None
            lclusters = []
            dist_clustering_max = 250
            for points in lshapes:  # For each shape
                if len(lclusters) == 0:
                    lclusters.append([points])
                else:
                    added_to_existing_cluster = False
                    for i, cluster_list in enumerate(
                            lclusters):  # We iterate over cluster and search if this shape is nearby a cluster
                        for shape_cluster_points in cluster_list:
                            # We check if one min distance between two vertrices is lower than the threshold
                            for vertex_pt1, vertex_pt2 in zip(shape_cluster_points,
                                                              shape_cluster_points[1:] + [shape_cluster_points[0]]):
                                for point1, point2 in zip(points, points[1:] + [points[0]]):
                                    try:
                                        if min_distance(*vertex_pt1, *vertex_pt2,
                                                        *point1, *point2) &lt; dist_clustering_max:
                                            lclusters[i].append(points)
                                            added_to_existing_cluster = True
                                            break
                                    except Exception as e:
                                        print(e)
                                        raise Exception()

                                if added_to_existing_cluster is True:
                                    break
                            if added_to_existing_cluster is True:
                                break
                        if added_to_existing_cluster is True:
                            break
                    if added_to_existing_cluster is False:
                        lclusters.append([points])
            # Drawing the shapes with one color per cluster: only for debugging purpose
            # Use directly all points from each cluster to compute boxes
            clean_img = np.zeros((*img.shape, 3), dtype=np.uint8)
            segmentation_map = Image.fromarray(clean_img)
            draw = ImageDraw.ImageDraw(segmentation_map)
            get_color = lambda x: matplotlib.colors.to_hex([*colorsys.hsv_to_rgb(x / len(lclusters), 1, 1)])
            print(f&#34;{len(lclusters)} clusters found&#34;)
            for i, cluster in enumerate(lclusters):
                print(f&#34;\t- {len(cluster)} shapes : &#34;, cluster)
                cv2.minAreaRect(np.array())
                for shape_points in cluster:
                    color = get_color(i)
                    draw.polygon(shape_points, fill=color)

            plt.figure()
            plt.imshow(np.asarray(segmentation_map), cmap=&#34;gray&#34;)
            plt.figure()
            plt.imshow(img.astype(np.uint8), cmap=&#34;gray&#34;)
            plt.show()
            break</code></pre>
</details>
</dd>
<dt id="main.src.data.preprocessing.create_cluster_dataset.min_distance"><code class="name flex">
<span>def <span class="ident">min_distance</span></span>(<span>x1, y1, x2, y2, x3, y3, x4, y4)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def min_distance(x1, y1, x2, y2, x3, y3, x4, y4):
    A = np.array([[2 * ((x1 - x2) ** 2 + (y1 - y2) ** 2), 2 * ((x1 - x2) * (x3 - x4) + (y1 - y2) * (y3 - y4))],
                  [2 * ((x1 - x2) * (x3 - x4) + (y1 - y2) * (y3 - y4)), 2 * ((x3 - x4) ** 2 + (y3 - y4) ** 2)]])

    B = np.array([[-2 * ((x1 - x2) * (x2 - x4) + (y1 - y2) * (y2 + y4))],
                  [-2 * ((x3 - x4) * (x2 - x4) + (y3 - y4) * (y2 + y4))]])

    # We want find the smallest distance between two point of two edges defined by their extremal points
    # One point satisfies the property that x = λx1 + (1-λ)x2 ; (idem with y) with x1,x2 (resp y1,y2) the x-(resp y) coordinates
    # of the extrimity of this vertex, with λ ∈ [0,1]
    # So we want to minimize
    #    ___________________________________________________________________________________________________________________
    #   ╱                                                     2                                                        2
    # ╲╱ ((λ1 ⋅ x1 + (1 - λ1) ⋅ x2) - (λ2 ⋅ x3 + (1 - λ2) ⋅ x4))  + ((λ1 ⋅ y1 + (1 - λ1) ⋅ y2) - (λ2 ⋅ y3 + (1 - λ2) ⋅ y4))
    # it is a non linear minimization problem with constraints. We will use trust-constr algorithm from scipy
    distance_btw_two_points_on_edges = lambda lambdas: distance(
        [lambdas[0] * x1 + (1 - lambdas[0]) * x2, lambdas[0] * y1 + (1 - lambdas[0]) * y2],
        [lambdas[1] * x3 + (1 - lambdas[1]) * x4, lambdas[1] * y3 + (1 - lambdas[1]) * y4])
    grad = np.array
    res = minimize(distance_btw_two_points_on_edges, [0.1, 0.1], method=&#39;trust-constr&#39;, options={&#39;disp&#39;: False},
                   tol=0.4,  # tolerance of 0.4 as we have a px distance
                   constraints=LinearConstraint(A=np.identity(2), lb=np.zeros((2,)) + 1e-3,
                                                ub=np.ones((2,))))  # λ ∈ [0,1]
    if res.success is False:
        raise Exception(&#34;Pb with minimization method: try to change the method used in the minimize function&#34;)
    return distance_btw_two_points_on_edges(res.x)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="main.src.data.preprocessing" href="index.html">main.src.data.preprocessing</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="main.src.data.preprocessing.create_cluster_dataset.distance" href="#main.src.data.preprocessing.create_cluster_dataset.distance">distance</a></code></li>
<li><code><a title="main.src.data.preprocessing.create_cluster_dataset.do" href="#main.src.data.preprocessing.create_cluster_dataset.do">do</a></code></li>
<li><code><a title="main.src.data.preprocessing.create_cluster_dataset.min_distance" href="#main.src.data.preprocessing.create_cluster_dataset.min_distance">min_distance</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>