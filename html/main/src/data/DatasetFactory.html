<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>main.src.data.DatasetFactory API documentation</title>
<meta name="description" content="Class managing the attr_dataset creation and access with different type of dataset possible" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>main.src.data.DatasetFactory</code></h1>
</header>
<section id="section-intro">
<p>Class managing the attr_dataset creation and access with different type of dataset possible</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;Class managing the attr_dataset creation and access with different type of dataset possible
&#34;&#34;&#34;

import json
from typing import Tuple, Dict, Optional

import torch

from main.FolderInfos import FolderInfos
from main.src.data.Datasets.AbstractDataset import AbstractDataset
from main.src.data.Datasets.HDF5Dataset import HDF5Dataset
from main.src.enums import EnumAugmenter
from main.src.enums import EnumBalance
from main.src.data.classification.ClassificationGeneratorCache import ClassificationGeneratorCache
from main.src.data.classification.ClassificationGeneratorPatch import ClassificationGeneratorPatch
from main.src.enums import EnumLabelModifier, EnumClassPatchAdder
from main.src.enums import EnumUsage, EnumClasses
from main.src.enums import EnumPatchAlgorithm, EnumPatchExcludePolicy
from main.src.param_savers.BaseClass import BaseClass


class DatasetFactory(BaseClass, torch.utils.data.IterableDataset):
    &#34;&#34;&#34;Class managing the attr_dataset creation and access with different type of dataset possible

    Args:
        dataset_name: EnumLabelModifier,
        usage_type: EnumUsage,
        grid_size: int, classification only with fixed_px size. To specify the size of a patch
        input_size: int, size of the image given to the attr_model
        exclusion_policy: EnumPatchExcludePolicy, policy to exclude patches. See [NoLabelModifier](./classification/NoLabelModifier.html)
        exclusion_policy_threshold: int, parameter for EnumPatchExcludePolicy.MarginMoreThan
        classes_to_use: Tuple[EnumClasses], the classes to use
        balance: EnumBalance,
        augmentations_img: opt str, list of augmentations to apply seprated by commas
        augmenter_img: opt EnumAugmenter,
        augmentation_factor: int, the number of times that the source image is augmented
        force_classifpatch: bool, force to use the class classificattionpatch
        other_class_adder: EnumClassPatchAdder to select classadder object
        interval: int, interval between two un annotated patches
        choose_dataset, Optional[str] &#34;cache&#34; to use the ClassificationCache method &#34;patch&#34;
    &#34;&#34;&#34;

    def __init__(self,
                 dataset_name: EnumLabelModifier = EnumLabelModifier.NoLabelModifier,
                 usage_type: EnumUsage = EnumUsage.Classification,
                 grid_size: int =1000,
                 input_size: int =1000,
                 exclusion_policy=EnumPatchExcludePolicy.MarginMoreThan,
                 exclusion_policy_threshold: int = 1000,
                 classes_to_use: Tuple[EnumClasses] = (EnumClasses.Other, EnumClasses.Seep, EnumClasses.Spill),
                 balance: EnumBalance = EnumBalance.NoBalance,
                 augmentations_img: str=&#34;none&#34;,
                 augmenter_img: EnumAugmenter = EnumAugmenter.NoAugmenter,
                 augmentation_factor=1, force_classifpatch=False,
                 other_class_adder: EnumClassPatchAdder = EnumClassPatchAdder.NoClassPatchAdder,
                 interval: int = 1,
                 choose_dataset: Optional[str] = None
                 ):
        self.attr_global_name = &#34;data&#34;

        if usage_type == EnumUsage.Classification:
            if (input_size == 256 and balance == EnumBalance.BalanceClasses1 and augmenter_img == EnumAugmenter.Augmenter1
                    and augmentations_img == &#34;combinedRotResizeMir_10_0.25_4&#34;  and
                    exclusion_policy == EnumPatchExcludePolicy.MarginMoreThan and exclusion_policy_threshold == 10
                    and grid_size == 1000 and not force_classifpatch or choose_dataset == &#34;cache&#34;) and choose_dataset != &#34;patch&#34;:
                self.attr_dataset = ClassificationGeneratorCache(label_modifier=dataset_name, classes_to_use=classes_to_use,
                                                                 other_class_adder=other_class_adder, interval=interval)
            else:
                self.attr_dataset = ClassificationGeneratorPatch(input_size=input_size,
                                                                 classes_to_use=classes_to_use,
                                                                 balance=balance,
                                                                 augmentations_img=augmentations_img,
                                                                 augmenter_img=augmenter_img,
                                                                 augmentation_factor=augmentation_factor,
                                                                 label_modifier=dataset_name,
                                                                 grid_size_px=grid_size,
                                                                 threshold_margin=exclusion_policy_threshold
                                                                 )


        elif usage_type == EnumUsage.Segmentation:
            if dataset_name == &#34;sentinel1&#34;:
                raise NotImplementedError()
        else:
            raise NotImplementedError()

    def __iter__(self, dataset):
        return self.attr_dataset.__iter__(dataset)

    def len(self, dataset):
        return self.attr_dataset.len(dataset)

    def set_datasets(self,image_dataset: HDF5Dataset, label_dataset: AbstractDataset, dico_infos: Dict):
        &#34;&#34;&#34;Change the origin of the patches

        Args:
            image_dataset: HDF5Dataset
            label_dataset: AbstractDataset Points or Images
            dico_infos: Dict, containing for each id of image the source image (under key source_img) and the transformation matrix (under key transformation_matrix) applied to get the patch
        Returns:

        &#34;&#34;&#34;
        self.attr_dataset.set_datasets(image_dataset, label_dataset, dico_infos)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="main.src.data.DatasetFactory.DatasetFactory"><code class="flex name class">
<span>class <span class="ident">DatasetFactory</span></span>
<span>(</span><span>dataset_name: <a title="main.src.enums.EnumLabelModifier" href="../enums.html#main.src.enums.EnumLabelModifier">EnumLabelModifier</a> = EnumLabelModifier.NoLabelModifier, usage_type: <a title="main.src.enums.EnumUsage" href="../enums.html#main.src.enums.EnumUsage">EnumUsage</a> = EnumUsage.Classification, grid_size: int = 1000, input_size: int = 1000, exclusion_policy=EnumPatchExcludePolicy.MarginMoreThan, exclusion_policy_threshold: int = 1000, classes_to_use: Tuple[<a title="main.src.enums.EnumClasses" href="../enums.html#main.src.enums.EnumClasses">EnumClasses</a>] = (&lt;EnumClasses.Other: &#x27;other&#x27;&gt;, &lt;EnumClasses.Seep: &#x27;seep&#x27;&gt;, &lt;EnumClasses.Spill: &#x27;spill&#x27;&gt;), balance: <a title="main.src.enums.EnumBalance" href="../enums.html#main.src.enums.EnumBalance">EnumBalance</a> = EnumBalance.NoBalance, augmentations_img: str = 'none', augmenter_img: <a title="main.src.enums.EnumAugmenter" href="../enums.html#main.src.enums.EnumAugmenter">EnumAugmenter</a> = EnumAugmenter.NoAugmenter, augmentation_factor=1, force_classifpatch=False, other_class_adder: <a title="main.src.enums.EnumClassPatchAdder" href="../enums.html#main.src.enums.EnumClassPatchAdder">EnumClassPatchAdder</a> = EnumClassPatchAdder.NoClassPatchAdder, interval: int = 1, choose_dataset: Union[str, NoneType] = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Class managing the attr_dataset creation and access with different type of dataset possible</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>dataset_name</code></strong></dt>
<dd>EnumLabelModifier,</dd>
<dt><strong><code>usage_type</code></strong></dt>
<dd>EnumUsage,</dd>
<dt><strong><code>grid_size</code></strong></dt>
<dd>int, classification only with fixed_px size. To specify the size of a patch</dd>
<dt><strong><code>input_size</code></strong></dt>
<dd>int, size of the image given to the attr_model</dd>
<dt><strong><code>exclusion_policy</code></strong></dt>
<dd>EnumPatchExcludePolicy, policy to exclude patches. See <a href="./classification/NoLabelModifier.html">NoLabelModifier</a></dd>
<dt><strong><code>exclusion_policy_threshold</code></strong></dt>
<dd>int, parameter for EnumPatchExcludePolicy.MarginMoreThan</dd>
<dt><strong><code>classes_to_use</code></strong></dt>
<dd>Tuple[EnumClasses], the classes to use</dd>
<dt><strong><code>balance</code></strong></dt>
<dd>EnumBalance,</dd>
<dt><strong><code>augmentations_img</code></strong></dt>
<dd>opt str, list of augmentations to apply seprated by commas</dd>
<dt><strong><code>augmenter_img</code></strong></dt>
<dd>opt EnumAugmenter,</dd>
<dt><strong><code>augmentation_factor</code></strong></dt>
<dd>int, the number of times that the source image is augmented</dd>
<dt><strong><code>force_classifpatch</code></strong></dt>
<dd>bool, force to use the class classificattionpatch</dd>
<dt><strong><code>other_class_adder</code></strong></dt>
<dd>EnumClassPatchAdder to select classadder object</dd>
<dt><strong><code>interval</code></strong></dt>
<dd>int, interval between two un annotated patches</dd>
</dl>
<p>choose_dataset, Optional[str] "cache" to use the ClassificationCache method "patch"</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class DatasetFactory(BaseClass, torch.utils.data.IterableDataset):
    &#34;&#34;&#34;Class managing the attr_dataset creation and access with different type of dataset possible

    Args:
        dataset_name: EnumLabelModifier,
        usage_type: EnumUsage,
        grid_size: int, classification only with fixed_px size. To specify the size of a patch
        input_size: int, size of the image given to the attr_model
        exclusion_policy: EnumPatchExcludePolicy, policy to exclude patches. See [NoLabelModifier](./classification/NoLabelModifier.html)
        exclusion_policy_threshold: int, parameter for EnumPatchExcludePolicy.MarginMoreThan
        classes_to_use: Tuple[EnumClasses], the classes to use
        balance: EnumBalance,
        augmentations_img: opt str, list of augmentations to apply seprated by commas
        augmenter_img: opt EnumAugmenter,
        augmentation_factor: int, the number of times that the source image is augmented
        force_classifpatch: bool, force to use the class classificattionpatch
        other_class_adder: EnumClassPatchAdder to select classadder object
        interval: int, interval between two un annotated patches
        choose_dataset, Optional[str] &#34;cache&#34; to use the ClassificationCache method &#34;patch&#34;
    &#34;&#34;&#34;

    def __init__(self,
                 dataset_name: EnumLabelModifier = EnumLabelModifier.NoLabelModifier,
                 usage_type: EnumUsage = EnumUsage.Classification,
                 grid_size: int =1000,
                 input_size: int =1000,
                 exclusion_policy=EnumPatchExcludePolicy.MarginMoreThan,
                 exclusion_policy_threshold: int = 1000,
                 classes_to_use: Tuple[EnumClasses] = (EnumClasses.Other, EnumClasses.Seep, EnumClasses.Spill),
                 balance: EnumBalance = EnumBalance.NoBalance,
                 augmentations_img: str=&#34;none&#34;,
                 augmenter_img: EnumAugmenter = EnumAugmenter.NoAugmenter,
                 augmentation_factor=1, force_classifpatch=False,
                 other_class_adder: EnumClassPatchAdder = EnumClassPatchAdder.NoClassPatchAdder,
                 interval: int = 1,
                 choose_dataset: Optional[str] = None
                 ):
        self.attr_global_name = &#34;data&#34;

        if usage_type == EnumUsage.Classification:
            if (input_size == 256 and balance == EnumBalance.BalanceClasses1 and augmenter_img == EnumAugmenter.Augmenter1
                    and augmentations_img == &#34;combinedRotResizeMir_10_0.25_4&#34;  and
                    exclusion_policy == EnumPatchExcludePolicy.MarginMoreThan and exclusion_policy_threshold == 10
                    and grid_size == 1000 and not force_classifpatch or choose_dataset == &#34;cache&#34;) and choose_dataset != &#34;patch&#34;:
                self.attr_dataset = ClassificationGeneratorCache(label_modifier=dataset_name, classes_to_use=classes_to_use,
                                                                 other_class_adder=other_class_adder, interval=interval)
            else:
                self.attr_dataset = ClassificationGeneratorPatch(input_size=input_size,
                                                                 classes_to_use=classes_to_use,
                                                                 balance=balance,
                                                                 augmentations_img=augmentations_img,
                                                                 augmenter_img=augmenter_img,
                                                                 augmentation_factor=augmentation_factor,
                                                                 label_modifier=dataset_name,
                                                                 grid_size_px=grid_size,
                                                                 threshold_margin=exclusion_policy_threshold
                                                                 )


        elif usage_type == EnumUsage.Segmentation:
            if dataset_name == &#34;sentinel1&#34;:
                raise NotImplementedError()
        else:
            raise NotImplementedError()

    def __iter__(self, dataset):
        return self.attr_dataset.__iter__(dataset)

    def len(self, dataset):
        return self.attr_dataset.len(dataset)

    def set_datasets(self,image_dataset: HDF5Dataset, label_dataset: AbstractDataset, dico_infos: Dict):
        &#34;&#34;&#34;Change the origin of the patches

        Args:
            image_dataset: HDF5Dataset
            label_dataset: AbstractDataset Points or Images
            dico_infos: Dict, containing for each id of image the source image (under key source_img) and the transformation matrix (under key transformation_matrix) applied to get the patch
        Returns:

        &#34;&#34;&#34;
        self.attr_dataset.set_datasets(image_dataset, label_dataset, dico_infos)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="main.src.param_savers.BaseClass.BaseClass" href="../param_savers/BaseClass.html#main.src.param_savers.BaseClass.BaseClass">BaseClass</a></li>
<li>torch.utils.data.dataset.IterableDataset</li>
<li>torch.utils.data.dataset.Dataset</li>
<li>typing.Generic</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="main.src.data.DatasetFactory.DatasetFactory.len"><code class="name flex">
<span>def <span class="ident">len</span></span>(<span>self, dataset)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def len(self, dataset):
    return self.attr_dataset.len(dataset)</code></pre>
</details>
</dd>
<dt id="main.src.data.DatasetFactory.DatasetFactory.set_datasets"><code class="name flex">
<span>def <span class="ident">set_datasets</span></span>(<span>self, image_dataset: <a title="main.src.data.Datasets.HDF5Dataset.HDF5Dataset" href="Datasets/ImageDataset.html#main.src.data.Datasets.ImageDataset.ImageDataset">HDF5Dataset</a>, label_dataset: <a title="main.src.data.Datasets.AbstractDataset.AbstractDataset" href="Datasets/AbstractDataset.html#main.src.data.Datasets.AbstractDataset.AbstractDataset">AbstractDataset</a>, dico_infos: Dict)</span>
</code></dt>
<dd>
<div class="desc"><p>Change the origin of the patches</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>image_dataset</code></strong></dt>
<dd>HDF5Dataset</dd>
<dt><strong><code>label_dataset</code></strong></dt>
<dd>AbstractDataset Points or Images</dd>
<dt><strong><code>dico_infos</code></strong></dt>
<dd>Dict, containing for each id of image the source image (under key source_img) and the transformation matrix (under key transformation_matrix) applied to get the patch</dd>
</dl>
<p>Returns:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_datasets(self,image_dataset: HDF5Dataset, label_dataset: AbstractDataset, dico_infos: Dict):
    &#34;&#34;&#34;Change the origin of the patches

    Args:
        image_dataset: HDF5Dataset
        label_dataset: AbstractDataset Points or Images
        dico_infos: Dict, containing for each id of image the source image (under key source_img) and the transformation matrix (under key transformation_matrix) applied to get the patch
    Returns:

    &#34;&#34;&#34;
    self.attr_dataset.set_datasets(image_dataset, label_dataset, dico_infos)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="main.src.data" href="index.html">main.src.data</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="main.src.data.DatasetFactory.DatasetFactory" href="#main.src.data.DatasetFactory.DatasetFactory">DatasetFactory</a></code></h4>
<ul class="">
<li><code><a title="main.src.data.DatasetFactory.DatasetFactory.len" href="#main.src.data.DatasetFactory.DatasetFactory.len">len</a></code></li>
<li><code><a title="main.src.data.DatasetFactory.DatasetFactory.set_datasets" href="#main.src.data.DatasetFactory.DatasetFactory.set_datasets">set_datasets</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>