<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>main.src.data.preprocessing.correct_overlap_annotations API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>main.src.data.preprocessing.correct_overlap_annotations</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">from typing import Tuple, List

from h5py import File
import dbf
import geopandas as gpd
import numpy as np
import re
import json
from PIL import Image, ImageDraw
from rasterio.transform import Affine,rowcol

from main.FolderInfos import FolderInfos
def get_annotations():
    &#34;&#34;&#34; Extract annotation from the dbf table

    Returns: tuple of dicts:

    - annotations: provided as {idofannotation0: {&#34;id&#34;: uniq_id.strip(), &#34;label&#34;: type.strip(), &#34;points&#34;: []}}
    - name_to_annotations: provided as {imageuniqid:[idofannotation0,...]}

    &#34;&#34;&#34;
    FolderInfos.init(test_without_data=True)
    dbffile_path = FolderInfos.input_data_folder +&#34;originals&#34; +FolderInfos.separator +&#34;Hydrocarbures_liquides_Seeps_et_spills_WGS84.dbf&#34;
    annotations = {}
    name_to_annotations = {}
    with dbf.Table(dbffile_path) as table:  # Table containing the class and the index of the polygon
        for l in table:
            [id, id_img, id_nap, id_pol_nap, type, indice, sat, date, nom, mois, surface] = l
            nom = nom.split(&#34;\n&#34;)[0].strip()
            [_, t_init, t_end, uniq_id, preprocessing] = re.sub(
                &#34;^(([0-9A-Za-z]+_){4})(\\d{8}T\\d{6})_(\\d{8}T\\d{6})_(([0-9A-Za-z]+_[0-9A-Za-z]+_[0-9A-Za-z]+))_([^\\.]+)(\\.data)?$&#34;,
                &#34;\\1,\\3,\\4,\\5,\\7&#34;,
                nom
            ).split(&#34;,&#34;)
            annotations[id] = {&#34;id&#34;: uniq_id.strip(), &#34;label&#34;: type.strip(), &#34;points&#34;: []}
            if uniq_id not in name_to_annotations:
                name_to_annotations[uniq_id] = []
            name_to_annotations[uniq_id].append(id)
    return annotations,name_to_annotations
def get_annotations_points(annotations,name_to_annotations):
    &#34;&#34;&#34;

    Args:
        annotations: provided as {idofannotation0: {&#34;id&#34;: uniq_id.strip(), &#34;label&#34;: type.strip(), &#34;points&#34;: []}}
        name_to_annotations: provided as {imageuniqid:[idofannotation0,...]}

    Returns: tuple of dict

    - annotations: provided as {idofannotation0: {&#34;id&#34;: uniq_id.strip(), &#34;label&#34;: type.strip(), &#34;points&#34;: [[point1x,point1y],...]}}
    - name_to_annotations: provided as {imageuniqid:[idofannotation0,...]} (the same as the original)

    &#34;&#34;&#34;
    ## Open the shapefile
    shapefile_path = FolderInfos.input_data_folder +&#34;originals&#34; +FolderInfos.separator +&#34;Hydrocarbures_liquides_Seeps_et_spills_WGS84.shp&#34;
    shapefile = gpd.read_file(shapefile_path)
    with open(f&#34;{FolderInfos.input_data_folder}images_informations_preprocessed.json&#34;, &#39;r&#39;) as fp:
        dico_informations = json.load(fp)
    for i_shape, shape in enumerate(shapefile.geometry):
        print(i_shape)
        id_shape = shapefile.id[i_shape]
        name = annotations[id_shape][&#34;id&#34;]
        transform_array = np.array(dico_informations[name][&#34;transform&#34;])
        transform = Affine.from_gdal(a=transform_array[0, 0], b=transform_array[0, 1], c=transform_array[0, 2],
                                     d=transform_array[1, 0], e=transform_array[1, 1], f=transform_array[1, 2])
        get_px_coord = lambda x, y: rowcol(transform, x, y)
        liste_points_shape: List[Tuple[int, int]] = []  # will contain the list of point of this shape
        elem = shape.boundary  # extract the boundary of the object shape (with other properties)
        if elem.geom_type != &#34;LineString&#34;:  # the polygon is defined by a group of lines defines the polygon : https://help.arcgis.com/en/geodatabase/10.0/sdk/arcsde/concepts/geometry/shapes/types.htm
            # Utiliser le numéro de vertice pr éviter les croisements
            for line in elem:  # Loop through lines of the &#34;Multi&#34; - LineString
                coords = np.dstack(line.coords.xy).tolist()[0]  # get the list of points
                for point in coords:  # Extract the point of the polygon
                    px, py = get_px_coord(point[0], point
                    [1])  # Convert point coordinates from degrees to corresponding px coordinates
                    liste_points_shape.append(tuple([int(py), int(px)]))

        else:  # the polygon is defined one line which creates a closed shape
            coords = np.dstack(elem.coords.xy).tolist()[0]
            for point in coords:  # Extract the point of the polygon
                # Convert point coordinates from degrees to corresponding px coordinates
                px, py = get_px_coord(point[0], point[1])
                liste_points_shape.append(tuple([int(py), int(px)]))
        annotations[id_shape][&#34;points&#34;] = liste_points_shape
    return annotations,name_to_annotations
if __name__ == &#34;__main__&#34;:

    annotations, name_to_annotations = get_annotations_points(*get_annotations())

    with File(f&#34;{FolderInfos.input_data_folder}images_preprocessed.hdf5&#34; ,&#34;r&#34;) as images_hdf5:
        with File(f&#34;{FolderInfos.input_data_folder}annotations_labels_preprocessed.hdf5&#34; ,&#34;w&#34;) as annotations_labels_hdf5:

            for name in images_hdf5.keys():
                image_array = np.array(images_hdf5[name])
                # Shapefile segmentation map computation
                ## Create empty array with the same shape as the original image
                segmentation_map = np.zeros(shape=image_array.shape, dtype=np.uint8)
                segmentation_map = Image.fromarray(segmentation_map)
                draw = ImageDraw.ImageDraw(segmentation_map)  # draw the base image
                try:
                    for index_shape in name_to_annotations[name]:
                        label = annotations[index_shape][&#34;label&#34;]
                        liste_points_shape = annotations[index_shape][&#34;points&#34;]
                        if label == &#34;seep&#34;:  # Change color and so the value put in the array to create the label
                            color = &#34;#010101&#34;
                        elif label == &#34;spill&#34;:
                            color = &#34;#020202&#34;
                        else:
                            color = &#34;#000000&#34;
                        draw.polygon(liste_points_shape, fill=color)
                except:
                    print(f&#34;{name} has no annotation&#34;)
                    # Extract
                segmentation_map = np.array(segmentation_map, dtype=np.uint8)
                annotations_labels_hdf5.create_dataset(name, shape=segmentation_map.shape, dtype=&#39;i&#39;, data=segmentation_map,
                                                       compression=&#39;gzip&#39;, compression_opts=9)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="main.src.data.preprocessing.correct_overlap_annotations.get_annotations"><code class="name flex">
<span>def <span class="ident">get_annotations</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Extract annotation from the dbf table</p>
<p>Returns: tuple of dicts:</p>
<ul>
<li>annotations: provided as {idofannotation0: {"id": uniq_id.strip(), "label": type.strip(), "points": []}}</li>
<li>name_to_annotations: provided as {imageuniqid:[idofannotation0,&hellip;]}</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_annotations():
    &#34;&#34;&#34; Extract annotation from the dbf table

    Returns: tuple of dicts:

    - annotations: provided as {idofannotation0: {&#34;id&#34;: uniq_id.strip(), &#34;label&#34;: type.strip(), &#34;points&#34;: []}}
    - name_to_annotations: provided as {imageuniqid:[idofannotation0,...]}

    &#34;&#34;&#34;
    FolderInfos.init(test_without_data=True)
    dbffile_path = FolderInfos.input_data_folder +&#34;originals&#34; +FolderInfos.separator +&#34;Hydrocarbures_liquides_Seeps_et_spills_WGS84.dbf&#34;
    annotations = {}
    name_to_annotations = {}
    with dbf.Table(dbffile_path) as table:  # Table containing the class and the index of the polygon
        for l in table:
            [id, id_img, id_nap, id_pol_nap, type, indice, sat, date, nom, mois, surface] = l
            nom = nom.split(&#34;\n&#34;)[0].strip()
            [_, t_init, t_end, uniq_id, preprocessing] = re.sub(
                &#34;^(([0-9A-Za-z]+_){4})(\\d{8}T\\d{6})_(\\d{8}T\\d{6})_(([0-9A-Za-z]+_[0-9A-Za-z]+_[0-9A-Za-z]+))_([^\\.]+)(\\.data)?$&#34;,
                &#34;\\1,\\3,\\4,\\5,\\7&#34;,
                nom
            ).split(&#34;,&#34;)
            annotations[id] = {&#34;id&#34;: uniq_id.strip(), &#34;label&#34;: type.strip(), &#34;points&#34;: []}
            if uniq_id not in name_to_annotations:
                name_to_annotations[uniq_id] = []
            name_to_annotations[uniq_id].append(id)
    return annotations,name_to_annotations</code></pre>
</details>
</dd>
<dt id="main.src.data.preprocessing.correct_overlap_annotations.get_annotations_points"><code class="name flex">
<span>def <span class="ident">get_annotations_points</span></span>(<span>annotations, name_to_annotations)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="args">Args</h2>
<dl>
<dt><strong><code>annotations</code></strong></dt>
<dd>provided as {idofannotation0: {"id": uniq_id.strip(), "label": type.strip(), "points": []}}</dd>
<dt><strong><code>name_to_annotations</code></strong></dt>
<dd>provided as {imageuniqid:[idofannotation0,&hellip;]}</dd>
</dl>
<p>Returns: tuple of dict</p>
<ul>
<li>annotations: provided as {idofannotation0: {"id": uniq_id.strip(), "label": type.strip(), "points": [[point1x,point1y],&hellip;]}}</li>
<li>name_to_annotations: provided as {imageuniqid:[idofannotation0,&hellip;]} (the same as the original)</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_annotations_points(annotations,name_to_annotations):
    &#34;&#34;&#34;

    Args:
        annotations: provided as {idofannotation0: {&#34;id&#34;: uniq_id.strip(), &#34;label&#34;: type.strip(), &#34;points&#34;: []}}
        name_to_annotations: provided as {imageuniqid:[idofannotation0,...]}

    Returns: tuple of dict

    - annotations: provided as {idofannotation0: {&#34;id&#34;: uniq_id.strip(), &#34;label&#34;: type.strip(), &#34;points&#34;: [[point1x,point1y],...]}}
    - name_to_annotations: provided as {imageuniqid:[idofannotation0,...]} (the same as the original)

    &#34;&#34;&#34;
    ## Open the shapefile
    shapefile_path = FolderInfos.input_data_folder +&#34;originals&#34; +FolderInfos.separator +&#34;Hydrocarbures_liquides_Seeps_et_spills_WGS84.shp&#34;
    shapefile = gpd.read_file(shapefile_path)
    with open(f&#34;{FolderInfos.input_data_folder}images_informations_preprocessed.json&#34;, &#39;r&#39;) as fp:
        dico_informations = json.load(fp)
    for i_shape, shape in enumerate(shapefile.geometry):
        print(i_shape)
        id_shape = shapefile.id[i_shape]
        name = annotations[id_shape][&#34;id&#34;]
        transform_array = np.array(dico_informations[name][&#34;transform&#34;])
        transform = Affine.from_gdal(a=transform_array[0, 0], b=transform_array[0, 1], c=transform_array[0, 2],
                                     d=transform_array[1, 0], e=transform_array[1, 1], f=transform_array[1, 2])
        get_px_coord = lambda x, y: rowcol(transform, x, y)
        liste_points_shape: List[Tuple[int, int]] = []  # will contain the list of point of this shape
        elem = shape.boundary  # extract the boundary of the object shape (with other properties)
        if elem.geom_type != &#34;LineString&#34;:  # the polygon is defined by a group of lines defines the polygon : https://help.arcgis.com/en/geodatabase/10.0/sdk/arcsde/concepts/geometry/shapes/types.htm
            # Utiliser le numéro de vertice pr éviter les croisements
            for line in elem:  # Loop through lines of the &#34;Multi&#34; - LineString
                coords = np.dstack(line.coords.xy).tolist()[0]  # get the list of points
                for point in coords:  # Extract the point of the polygon
                    px, py = get_px_coord(point[0], point
                    [1])  # Convert point coordinates from degrees to corresponding px coordinates
                    liste_points_shape.append(tuple([int(py), int(px)]))

        else:  # the polygon is defined one line which creates a closed shape
            coords = np.dstack(elem.coords.xy).tolist()[0]
            for point in coords:  # Extract the point of the polygon
                # Convert point coordinates from degrees to corresponding px coordinates
                px, py = get_px_coord(point[0], point[1])
                liste_points_shape.append(tuple([int(py), int(px)]))
        annotations[id_shape][&#34;points&#34;] = liste_points_shape
    return annotations,name_to_annotations</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="main.src.data.preprocessing" href="index.html">main.src.data.preprocessing</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="main.src.data.preprocessing.correct_overlap_annotations.get_annotations" href="#main.src.data.preprocessing.correct_overlap_annotations.get_annotations">get_annotations</a></code></li>
<li><code><a title="main.src.data.preprocessing.correct_overlap_annotations.get_annotations_points" href="#main.src.data.preprocessing.correct_overlap_annotations.get_annotations_points">get_annotations_points</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>